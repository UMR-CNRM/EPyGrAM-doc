
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>epygram.geometries.AbstractGeometry &#8212; epygram 1.5.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinxdoc.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">epygram 1.5.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../epygram.html" >epygram</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../geometries.html" accesskey="U">epygram.geometries</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">epygram.geometries.AbstractGeometry</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for epygram.geometries.AbstractGeometry</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Copyright (c) Météo France (2014-)</span>
<span class="c1"># This software is governed by the CeCILL-C license under French law.</span>
<span class="c1"># http://www.cecill.info</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Contains the classes for 3D geometries of fields.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">import</span> <span class="nn">footprints</span>
<span class="kn">from</span> <span class="nn">footprints</span> <span class="kn">import</span> <span class="n">FPDict</span><span class="p">,</span> <span class="n">proxy</span> <span class="k">as</span> <span class="n">fpx</span>

<span class="kn">from</span> <span class="nn">epygram</span> <span class="kn">import</span> <span class="n">epygramError</span><span class="p">,</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">epygram.config</span> <span class="kn">import</span> <span class="n">rounding_decimal</span> <span class="k">as</span> <span class="n">_rd</span>
<span class="kn">from</span> <span class="nn">epygram.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">RecursiveObject</span><span class="p">,</span> <span class="n">degrees_nearest_mod</span><span class="p">,</span> <span class="n">Angle</span><span class="p">,</span>
                          <span class="n">positive_longitudes</span><span class="p">,</span> <span class="n">longitudes_between_minus180_180</span><span class="p">,</span>
                          <span class="n">separation_line</span><span class="p">,</span> <span class="n">write_formatted</span><span class="p">,</span>
                          <span class="n">as_numpy_array</span><span class="p">,</span> <span class="n">moveaxis</span><span class="p">,</span>
                          <span class="n">is_scalar</span><span class="p">,</span> <span class="n">Comparator</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.VGeometry</span> <span class="kn">import</span> <span class="n">VGeometry</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_need_pyproj_geod</span>

<span class="n">epylog</span> <span class="o">=</span> <span class="n">footprints</span><span class="o">.</span><span class="n">loggers</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">_re_nearest_sq</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;n&gt;\d+)\*(?P&lt;m&gt;\d+)&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="Geometry"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry">[docs]</a><span class="k">class</span> <span class="nc">Geometry</span><span class="p">(</span><span class="n">RecursiveObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles the geometry for a 3-Dimensions Field.</span>
<span class="sd">    Abstract mother class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ghost attributes are ignored when comparing 2 objects between them</span>
    <span class="n">_ghost_attributes</span> <span class="o">=</span> <span class="n">RecursiveObject</span><span class="o">.</span><span class="n">_ghost_attributes</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;_puredict&#39;</span><span class="p">,</span> <span class="s1">&#39;_observer&#39;</span><span class="p">]</span>  <span class="c1"># footprints special attributes</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">vcoordinate</span><span class="p">,</span>
                 <span class="n">position_on_horizontal_grid</span><span class="o">=</span><span class="s1">&#39;__unknown__&#39;</span><span class="p">,</span> <span class="n">geoid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param grid: Handles description of the horizontal grid.</span>
<span class="sd">        :param dimensions: Handles grid dimensions.</span>
<span class="sd">        :param vcoordinate: Handles vertical geometry parameters.</span>
<span class="sd">        :param position_on_horizontal_grid: Position of points w/r to the horizontal.</span>
<span class="sd">                                            among: [&#39;upper-right&#39;, &#39;upper-left&#39;,</span>
<span class="sd">                                                    &#39;lower-left&#39;, &#39;lower-right&#39;,</span>
<span class="sd">                                                    &#39;center-left&#39;, &#39;center-right&#39;,</span>
<span class="sd">                                                    &#39;lower-center&#39;, &#39;upper-center&#39;,</span>
<span class="sd">                                                    &#39;center&#39;, &#39;__unknown__&#39;]</span>
<span class="sd">        :param geoid: To specify geoid shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_attr_dict</span><span class="p">(</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_attr_dict</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_attr_class</span><span class="p">(</span><span class="s1">&#39;vcoordinate&#39;</span><span class="p">,</span> <span class="n">VGeometry</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_attr_inlist</span><span class="p">(</span><span class="s1">&#39;position_on_horizontal_grid&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;upper-right&#39;</span><span class="p">,</span> <span class="s1">&#39;upper-left&#39;</span><span class="p">,</span>
                                                             <span class="s1">&#39;lower-left&#39;</span><span class="p">,</span> <span class="s1">&#39;lower-right&#39;</span><span class="p">,</span>
                                                             <span class="s1">&#39;center-left&#39;</span><span class="p">,</span> <span class="s1">&#39;center-right&#39;</span><span class="p">,</span>
                                                             <span class="s1">&#39;lower-center&#39;</span><span class="p">,</span> <span class="s1">&#39;upper-center&#39;</span><span class="p">,</span>
                                                             <span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;__unknown__&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_attr_dict</span><span class="p">(</span><span class="s1">&#39;geoid&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">vcoordinate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position_on_horizontal_grid</span> <span class="o">=</span> <span class="n">position_on_horizontal_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">geoid</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">default_geoid</span> <span class="k">if</span> <span class="n">geoid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">geoid</span>

        <span class="c1"># Checks !</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consistency_check</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_consistency_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># implemented in child classes</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_GRIB2_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build GRIB2 sample name.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">epygram.extra.griberies.tables</span> <span class="kn">import</span> <span class="n">typeoffixedsurface2sample</span> <span class="k">as</span> <span class="n">levels</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s1">&#39;H2D&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">prefix</span><span class="p">,</span>
                             <span class="n">levels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">typeoffirstfixedsurface</span><span class="p">,</span> <span class="s1">&#39;sfc&#39;</span><span class="p">),</span>
                             <span class="s1">&#39;grib2&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the structure of the grid which depends on the prsent dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">has_k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="n">has_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lat_number&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="n">has_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;max_lon_number&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="p">{(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span> <span class="s1">&#39;3D&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span> <span class="s1">&#39;H2D&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span> <span class="s1">&#39;H1D&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span> <span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span> <span class="s1">&#39;V2D&#39;</span><span class="p">,</span>
                <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span> <span class="s1">&#39;V1D&#39;</span><span class="p">,</span>
               <span class="p">}[(</span><span class="n">has_i</span><span class="p">,</span> <span class="n">has_j</span><span class="p">,</span> <span class="n">has_k</span><span class="p">)]</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rectangular_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Is the grid rectangular ? &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">RectangularGridGeometry</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">projected_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Is the geometry a projection ? &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.ProjectedGeometry</span> <span class="kn">import</span> <span class="n">ProjectedGeometry</span> <span class="c1">#Imported here to prevent circular import</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ProjectedGeometry</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">datashape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the data shape requested by this geometry.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;3D&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;V2D&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;H2D&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;H1D&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;V1D&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;Point&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s1">&#39;This structure is unknown&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Geometry.get_levels"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.get_levels">[docs]</a>    <span class="k">def</span> <span class="nf">get_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nb_validities</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an array containing the level for each data point.</span>

<span class="sd">        :param d4: - if True,  returned values are shaped in a 4 dimensions array</span>
<span class="sd">                   - if False, shape of returned values is determined with respect to geometry</span>
<span class="sd">                     d4=True requires nb_validities &gt; 0</span>
<span class="sd">        :param nb_validities: the number of validities represented in data values</span>
<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, extracts</span>
<span class="sd">          the levels resp. from the C or C+I zone off the C+I(+E) zone.</span>

<span class="sd">        Levels are internally stored with the vertical dimension first whereas this</span>
<span class="sd">        method puts the time in first dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">d4</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nb_validities</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nb_validities must be &gt;=1 when d4==True&quot;</span><span class="p">)</span>

        <span class="n">levels</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>

        <span class="c1"># We add the horizontal axis</span>
        <span class="n">h_shape2D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">d4</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">dimT</span><span class="o">=</span><span class="n">nb_validities</span><span class="p">,</span>
                                       <span class="n">force_dimZ</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                       <span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># level values constant over the horizontal domain and time</span>
            <span class="c1"># We add the horizontal dimension</span>
            <span class="n">original_has_time</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">d4</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">h_shape2D</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">h_shape2D</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">d4</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">h_shape2D</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">h_shape2D</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># level values with horizontal variations</span>
            <span class="n">h_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">force_dimZ</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># workaround for inconsistency between rectangular and gauss, self.get_datashape(force_dimZ=1)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_shape</span><span class="p">):</span>
                <span class="n">original_has_time</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_shape</span><span class="p">):</span>
                <span class="n">original_has_time</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;Wrong number of dimensions&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_shape</span><span class="p">):]</span> <span class="o">!=</span> <span class="n">h_shape</span><span class="p">:</span>  <span class="c1"># OK for h_shape=tuple()</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;Shape of self.vcoordinate.levels does not agree with horizontal dimensions&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subzone</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_subzone</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">subzone</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d4</span> <span class="ow">and</span> <span class="p">((</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">])):</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_shape</span><span class="p">)]</span>  <span class="c1"># shape without the horizontal dimensions, OK for h_shape=tuple()</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">h_shape2D</span><span class="p">))</span>  <span class="c1"># shape with the new horizontal dimensions</span>
                <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># We suppress the vertical dimension if we do not need it</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">d4</span> <span class="ow">and</span> <span class="n">nb_validities</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># We add the time axis</span>
        <span class="k">if</span> <span class="n">original_has_time</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nb_validities</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;Shape of self.vcoordinate.levels does not agree with nb_validities&quot;</span><span class="p">)</span>
            <span class="n">shape_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">2</span><span class="p">:])))</span>
        <span class="k">elif</span> <span class="n">d4</span> <span class="ow">or</span> <span class="n">nb_validities</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">nb_validities</span><span class="p">])</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">nb_validities</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">shape_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">shape_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>  <span class="c1"># last axis in first</span>

        <span class="k">return</span> <span class="n">levels</span></div>

<div class="viewcode-block" id="Geometry.vcoord_as_field"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.vcoord_as_field">[docs]</a>    <span class="k">def</span> <span class="nf">vcoord_as_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface_type</span><span class="p">,</span> <span class="n">validity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a field filled with the level values associated to a fake geometry</span>
<span class="sd">        :param validity: validities to associate with the returned field</span>
<span class="sd">                         if None, we try without setting validity</span>
<span class="sd">        :param surface_type: typeOfFirstFixedSurface to associate to the fake geometry</span>
<span class="sd">        :param levels: list of values to use as the levels of the fake geometry</span>
<span class="sd">                       if None, levels will be replaced by a range</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">typeOfFirstFixedSurface</span> <span class="o">=</span> <span class="n">surface_type</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)))</span> <span class="k">if</span> <span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">levels</span>
        <span class="n">field_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fid</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">temp</span><span class="o">=</span><span class="s1">&#39;temp&#39;</span><span class="p">),</span>
                            <span class="n">structure</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span>
                            <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">validity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">field_kwargs</span><span class="p">[</span><span class="s1">&#39;validity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">validity</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="o">**</span><span class="n">field_kwargs</span><span class="p">)</span>
        <span class="n">field</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_levels</span><span class="p">(</span><span class="n">d4</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nb_validities</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">validity</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">validity</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">field</span></div>

    <span class="k">def</span> <span class="nf">_getoffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the offset to use for this **position**.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">position</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_on_horizontal_grid</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="s1">&#39;__unknown__&#39;</span> <span class="ow">or</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;position_on_horizontal_grid must be&quot;</span> <span class="o">+</span>
                               <span class="s2">&quot; defined.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;upper-right&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;upper-left&#39;</span>  <span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;lower-left&#39;</span>  <span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;lower-right&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="mf">.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;center-left&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span>
                <span class="s1">&#39;center-right&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span>
                <span class="s1">&#39;lower-center&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;upper-center&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;center&#39;</span>      <span class="p">:</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)}[</span><span class="n">pos</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_set_geoid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pyproj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Geod</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">)</span>

    <span class="nd">@_need_pyproj_geod</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the distance between two points along a Great Circle.</span>

<span class="sd">        :param end1: first point, must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: second point, must be a tuple (lon, lat) in degrees.</span>

<span class="sd">        If one of (end1, end2) is a tuple of arrays (like (&lt;array of lon&gt;, &lt;array of lat&gt;))</span>
<span class="sd">        the other one must be a scalar tuple or a tuple of arrays with same dimensions.</span>

<span class="sd">        Warning: requires the :mod:`pyproj` module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">[</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
        <span class="n">end1_0</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">end1_1</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">end2_0</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">end2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">end2_1</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">end2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_1</span><span class="p">),</span> <span class="s1">&#39;pb with dims&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;only scalars or 1D arrays&#39;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">end1_0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">end1_0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">end1_1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">end1_1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">end2_0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">end2_0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">end2_1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">end2_1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s1">&#39;at least one point must be fixed or both arrays must have the same length&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">end1_0</span><span class="p">,</span> <span class="n">end1_1</span><span class="p">,</span> <span class="n">end2_0</span><span class="p">,</span> <span class="n">end2_1</span><span class="p">]]:</span>
            <span class="c1"># inv method does not like masked arrays</span>
            <span class="c1"># and can raise a ValueError: undefined inverse geodesic (may be an antipodal point)</span>
            <span class="c1"># on masked points</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">end1_0</span> <span class="o">+</span> <span class="n">end1_1</span> <span class="o">+</span> <span class="n">end2_0</span> <span class="o">+</span> <span class="n">end2_1</span><span class="p">))</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">end1_0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">distance</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">end1_0</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">end1_1</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">end2_0</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">end2_1</span><span class="p">[</span><span class="n">mask</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">end1_0</span><span class="p">,</span> <span class="n">end1_1</span><span class="p">,</span> <span class="n">end2_0</span><span class="p">,</span> <span class="n">end2_1</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">scalar</span> <span class="k">else</span> <span class="n">distance</span>

    <span class="nd">@_need_pyproj_geod</span>
    <span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns evenly spaced points over the specified interval.</span>
<span class="sd">        Points are lined up along a Great Circle.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param num: the number of points, including point1 and point2.</span>

<span class="sd">        Warning: requires the :mod:`pyproj` module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;num&#39; must be at least 2.&quot;</span><span class="p">)</span>
        <span class="n">transect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                          <span class="n">end2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                          <span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">transect</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end1</span><span class="p">)</span>
        <span class="n">transect</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transect</span>

    <span class="nd">@_need_pyproj_geod</span>
    <span class="k">def</span> <span class="nf">azimuth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initial bearing from *end1* to *end2* points following a Great Circle.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>

<span class="sd">        Warning: requires the :mod:`pyproj` module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Geometry.make_point_geometry"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.make_point_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_point_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a Geometry at coordinates *(lon,lat)* in degrees.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.UnstructuredGeometry</span> <span class="kn">import</span> <span class="n">UnstructuredGeometry</span> <span class="c1">#Imported here to prevent circular import</span>
        <span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">VGeometry</span><span class="p">(</span><span class="n">typeoffirstfixedsurface</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
                                <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">UnstructuredGeometry</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;unstructured&#39;</span><span class="p">,</span>
                                    <span class="n">vcoordinate</span><span class="o">=</span><span class="n">vcoordinate</span><span class="p">,</span>
                                    <span class="n">dimensions</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span>
                                    <span class="n">grid</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;longitudes&#39;</span><span class="p">:[</span><span class="n">lon</span><span class="p">],</span>
                                          <span class="s1">&#39;latitudes&#39;</span><span class="p">:[</span><span class="n">lat</span><span class="p">]},</span>
                                    <span class="n">position_on_horizontal_grid</span><span class="o">=</span><span class="s1">&#39;center&#39;</span>
                                    <span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.make_profile_geometry"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.make_profile_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_profile_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a V1DGeometry at coordinates *(lon,lat)* in degrees.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.UnstructuredGeometry</span> <span class="kn">import</span> <span class="n">UnstructuredGeometry</span> <span class="c1">#Imported here to prevent circular import</span>
        <span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">VGeometry</span><span class="p">(</span><span class="n">typeoffirstfixedsurface</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
                                <span class="n">levels</span><span class="o">=</span><span class="p">[])</span>
        <span class="k">return</span> <span class="n">UnstructuredGeometry</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;unstructured&#39;</span><span class="p">,</span>
                                    <span class="n">vcoordinate</span><span class="o">=</span><span class="n">vcoordinate</span><span class="p">,</span>
                                    <span class="n">dimensions</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span>
                                    <span class="n">grid</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;longitudes&#39;</span><span class="p">:[</span><span class="n">lon</span><span class="p">],</span>
                                          <span class="s1">&#39;latitudes&#39;</span><span class="p">:[</span><span class="n">lat</span><span class="p">]},</span>
                                    <span class="n">position_on_horizontal_grid</span><span class="o">=</span><span class="s1">&#39;center&#39;</span>
                                    <span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.make_section_geometry"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.make_section_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_section_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span>
                              <span class="n">points_number</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param points_number: defines the total number of horizontal points of the</span>
<span class="sd">          section (including ends). If None, defaults to a number computed from</span>
<span class="sd">          the *ends* and the *resolution*.</span>
<span class="sd">        :param resolution: defines the horizontal resolution to be given to the</span>
<span class="sd">          field. If None, defaults to the horizontal resolution of the field.</span>
<span class="sd">        :param position: defines the position of data in the grid (for projected grids only)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.UnstructuredGeometry</span> <span class="kn">import</span> <span class="n">UnstructuredGeometry</span> <span class="c1">#Imported here to prevent circular import</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end2</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end2</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">position</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;center&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;position can only be None or &#39;center&#39; for non-projected geometries.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;only one of resolution and &quot;</span> <span class="o">+</span>
                               <span class="s2">&quot; points_number can be given.&quot;</span><span class="p">)</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span> <span class="o">+</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">resolution</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;ends&#39; are too near: pure&quot;</span> <span class="o">+</span>
                                   <span class="s2">&quot; interpolation between two gridpoints.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">points_number</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;points_number&#39; must be at least 2.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">points_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">points_number</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">transect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">points_number</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">points_number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">transect</span> <span class="o">=</span> <span class="p">[</span><span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;cannot make a section with less than&quot;</span> <span class="o">+</span>
                               <span class="s2">&quot; 2 points.&quot;</span><span class="p">)</span>
        <span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">VGeometry</span><span class="p">(</span><span class="n">typeoffirstfixedsurface</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
                                <span class="n">levels</span><span class="o">=</span><span class="p">[])</span>
        <span class="n">kwargs_geom</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;unstructured&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;vcoordinate&#39;</span><span class="p">:</span><span class="n">vcoordinate</span><span class="p">,</span>
                       <span class="s1">&#39;dimensions&#39;</span><span class="p">:{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">transect</span><span class="p">),</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span>
                       <span class="s1">&#39;grid&#39;</span><span class="p">:{</span><span class="s1">&#39;longitudes&#39;</span><span class="p">:[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">transect</span><span class="p">],</span>
                               <span class="s1">&#39;latitudes&#39;</span><span class="p">:[</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">transect</span><span class="p">]},</span>
                       <span class="s1">&#39;position_on_horizontal_grid&#39;</span><span class="p">:</span><span class="s1">&#39;center&#39;</span> <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">position</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">:</span>
            <span class="n">kwargs_geom</span><span class="p">[</span><span class="s1">&#39;geoid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoid</span>
        <span class="k">return</span> <span class="n">UnstructuredGeometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_geom</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.make_physicallevels_geometry"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.make_physicallevels_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_physicallevels_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new geometry excluding levels with no physical meaning.</span>

<span class="sd">        :param getdata: if False returns a field without data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">typeoffirstfixedsurface</span> <span class="o">==</span> <span class="mi">118</span><span class="p">:</span>
            <span class="c1"># build vertical geometry</span>
            <span class="n">kwargs_vcoord</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;typeoffirstfixedsurface&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">typeoffirstfixedsurface</span><span class="p">,</span>
                             <span class="s1">&#39;position_on_grid&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">position_on_grid</span><span class="p">,</span>
                             <span class="s1">&#39;grid&#39;</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">grid</span><span class="p">),</span>
                             <span class="s1">&#39;levels&#39;</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)}</span>
            <span class="c1"># Suppression of levels above or under physical domain</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs_vcoord</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;gridlevels&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">kwargs_vcoord</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="c1"># build geometry</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">VGeometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_vcoord</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">geometry</span></div>

<div class="viewcode-block" id="Geometry.make_zoom_geometry"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.make_zoom_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_zoom_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">extra_10th</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an unstructured geometry with the points contained in *zoom*.</span>

<span class="sd">        :param zoom: a dict(lonmin=, lonmax=, latmin=, latmax=).</span>
<span class="sd">        :param extra_10th: if True, add 1/10th of the X/Y extension of the zoom</span>
<span class="sd">                           (only usefull for the regular_lonlat grid implementation).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.UnstructuredGeometry</span> <span class="kn">import</span> <span class="n">UnstructuredGeometry</span> <span class="c1">#Imported here to prevent circular import</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">()</span>
        <span class="n">kwargs_zoomgeom</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vcoordinate&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(),</span>
                           <span class="s1">&#39;position_on_horizontal_grid&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">position_on_horizontal_grid</span><span class="p">,</span>
                           <span class="s1">&#39;geoid&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">}</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">zoomlons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">zoomlats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">flat_indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmin&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmax&#39;</span><span class="p">]</span> <span class="ow">and</span> \
               <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmin&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmax&#39;</span><span class="p">]:</span>
                <span class="n">zoomlons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">zoomlats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lats</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">flat_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">zoomlons</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;zoom not in domain.&quot;</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">zoomlons</span><span class="p">),</span>
                                         <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;unstructured&#39;</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;longitudes&#39;</span><span class="p">:</span><span class="n">zoomlons</span><span class="p">,</span>
                                   <span class="s1">&#39;latitudes&#39;</span><span class="p">:</span><span class="n">zoomlats</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">UnstructuredGeometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_zoomgeom</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_reshape_lonlat_4d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">nb_validities</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make lons, lats grids 4D.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nb_validities</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nb_validities must be &gt;=1 when d4==True&quot;</span><span class="p">)</span>
        <span class="c1"># We add vertical dimension, and missing horizontal dimension</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lons</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shape</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)])</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">shape_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">shape_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>  <span class="c1"># last axis in first</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">shape_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>  <span class="c1"># last axis in first</span>
        <span class="c1"># We add validities</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">lons</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">nb_validities</span><span class="p">])</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">nb_validities</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">nb_validities</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">shape_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">shape_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>  <span class="c1"># last axis in first</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">shape_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>  <span class="c1"># last axis in first</span>
        <span class="k">return</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span>

<div class="viewcode-block" id="Geometry.eq_Hgeom"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.eq_Hgeom">[docs]</a>    <span class="k">def</span> <span class="nf">eq_Hgeom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests if the horizontal part of the geometry is equal to</span>
<span class="sd">        the horizontal part of another geometry.</span>
<span class="sd">        :param: other: other geometry to use in the comparison</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">),</span> <span class="s2">&quot;Other must be a geometry object&quot;</span>
        <span class="n">vc_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">vcoordinate</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">vc_self</span>
        <span class="k">return</span> <span class="n">result</span></div>

<span class="c1">###################</span>
<span class="c1"># PRE-APPLICATIVE #</span>
<span class="c1">###################</span>
<span class="c1"># (but useful and rather standard) !</span>
<span class="c1"># [so that, subject to continuation through updated versions,</span>
<span class="c1">#  including suggestions/developments by users...]</span>

<div class="viewcode-block" id="Geometry.make_field"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.make_field">[docs]</a>    <span class="k">def</span> <span class="nf">make_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a field out of the geometry.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">ll_field</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;H2D&#39;</span><span class="p">,</span>
                             <span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">fid</span><span class="o">=</span><span class="n">FPDict</span><span class="p">({</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="n">fid</span><span class="p">}))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]))</span>
        <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">ll_field</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ll_field</span></div>

<div class="viewcode-block" id="Geometry.plotgeometry"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.plotgeometry">[docs]</a>    <span class="k">def</span> <span class="nf">plotgeometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">plotlib</span><span class="o">=</span><span class="s1">&#39;cartopy&#39;</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a simple plot of the geometry, with a number of options.</span>

<span class="sd">        :param plotlib: library to be used for plotting: &#39;basemap&#39; is DEPRECATED;</span>
<span class="sd">            &#39;cartopy&#39; (default) is recommended !</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">plotlib</span> <span class="o">==</span> <span class="s1">&#39;cartopy&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cartoplot_geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;basemap&#39; plotlib has been removed, only remains &#39;cartopy&#39;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.cartoplot_geometry"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.cartoplot_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">cartoplot_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a simple plot of the geometry, using cartopy.</span>
<span class="sd">        For kwargs please refer to epygram.geometries.domain_making.output.cartoplot_rect_geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">epygram.geometries.domain_making.output</span> <span class="kn">import</span> <span class="n">cartoplot_rect_geometry</span>
        <span class="k">if</span> <span class="s1">&#39;color&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>  <span class="c1"># compatibility dirty-fix</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;contourcolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">cartoplot_rect_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Geometry.what"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.Geometry.what">[docs]</a>    <span class="k">def</span> <span class="nf">what</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
             <span class="n">vertical_geometry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">arpifs_var_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">spectral_geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the geometry.</span>

<span class="sd">        :param out: the output open file-like object (duck-typing: *out*.write()</span>
<span class="sd">          only is needed).</span>
<span class="sd">        :param vertical_geometry: if True, writes the vertical geometry of the</span>
<span class="sd">          field.</span>
<span class="sd">        :param arpifs_var_names: if True, prints the equivalent &#39;arpifs&#39; variable</span>
<span class="sd">          names.</span>
<span class="sd">        :param spectral_geometry: an optional dict containing the spectral</span>
<span class="sd">          truncatures {&#39;in_X&#39;:, &#39;in_Y&#39;:}  (LAM) or {&#39;max&#39;:} (global).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;###########################</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;### HORIZONTAL GEOMETRY ###</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;###########################</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Rectangular grid ( = LAM or reg. Lon/Lat)&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rectangular_grid</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_what_grid_dimensions</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">spectral_geometry</span><span class="o">=</span><span class="n">spectral_geometry</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rectangular_grid</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_geometry</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_what_projection</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">arpifs_var_names</span><span class="o">=</span><span class="n">arpifs_var_names</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;regular_lonlat&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_what_grid</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">arpifs_var_names</span><span class="o">=</span><span class="n">arpifs_var_names</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_lonlat&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_what_grid</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;academic&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_what_position</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;unstructured&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_what_grid</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">separation_line</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vertical_geometry</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">what</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RectangularGridGeometry"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry">[docs]</a><span class="k">class</span> <span class="nc">RectangularGridGeometry</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles the geometry for a rectangular 3-Dimensions Field.</span>
<span class="sd">    Abstract.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isglobal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: True if geometry is global</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Apart for global lon-lat</span>

    <span class="k">def</span> <span class="nf">suggested_GRIB2_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectral</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s1">&#39;H2D&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">spectral</span><span class="p">:</span>
                <span class="c1"># return self._GRIB2_sample(regular_ll&#39;)</span>
                <span class="k">return</span> <span class="s1">&#39;GRIB2&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GRIB2_sample</span><span class="p">(</span><span class="s1">&#39;sh&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indextype</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of two tables containing the two indexes of each</span>
<span class="sd">        point, with 2D shape.</span>

<span class="sd">        :param indextype: either &#39;ij&#39;, &#39;xy&#39; or &#39;ll&#39; to get</span>
<span class="sd">          i,j indexes, x,y coordinates or lon,lat coordinates</span>
<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, returns</span>
<span class="sd">          the grid resp. for the C or C+I zone off the C+I+E zone. \n</span>
<span class="sd">          Default is no subzone, i.e. the whole field.</span>
<span class="sd">        :param position: position of lonlat grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]),</span>
                                      <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]))</span>
        <span class="n">igrid</span> <span class="o">=</span> <span class="n">igrid</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">jgrid</span> <span class="o">=</span> <span class="n">jgrid</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">indextype</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">indextype</span> <span class="o">==</span> <span class="s1">&#39;ll&#39;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">indextype</span> <span class="o">==</span> <span class="s1">&#39;ij&#39;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;*indextype*== &#39;</span> <span class="o">+</span> <span class="n">indextype</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subzone</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_subzone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subzone</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_subzone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">subzone</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gridpoints_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of gridpoints of the grid.</span>

<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, returns</span>
<span class="sd">          the grid resp. for the C or C+I zone off the C+I+E zone. \n</span>
<span class="sd">          Default is no subzone, i.e. the whole field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">dimT</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">force_dimZ</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="RectangularGridGeometry.get_lonlat_grid"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.get_lonlat_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_lonlat_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">nb_validities</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">force_longitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of two tables containing one the longitude of each</span>
<span class="sd">        point, the other the latitude, with 2D shape.</span>

<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, returns</span>
<span class="sd">          the grid resp. for the C or C+I zone off the C+I+E zone. \n</span>
<span class="sd">          Default is no subzone, i.e. the whole field.</span>
<span class="sd">        :param position: position of lonlat grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        :param d4: - if True,  returned values are shaped in a 4 dimensions array</span>
<span class="sd">                   - if False, shape of returned values is determined with</span>
<span class="sd">                     respect to geometry. d4=True requires nb_validities &gt; 0</span>
<span class="sd">        :param nb_validities: number of validities represented in data values</span>
<span class="sd">        :param force_longitudes: if &#39;positive&#39;, the longitudes will be forced positive</span>
<span class="sd">                                 if &#39;]-180,180]&#39;, the longitudes will be in the ]-180, 180] interval</span>

<span class="sd">        Shape of 2D data on Rectangular grids: \n</span>
<span class="sd">          - grid[0,0] is SW, grid[-1,-1] is NE \n</span>
<span class="sd">          - grid[0,-1] is SE, grid[-1,0] is NW</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grid</span><span class="p">(</span><span class="s1">&#39;ll&#39;</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d4</span><span class="p">:</span>
            <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_lonlat_4d</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">nb_validities</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">d4</span> <span class="ow">and</span> <span class="n">nb_validities</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;*nb_validities* must be 0 when d4==False&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">force_longitudes</span> <span class="o">==</span> <span class="s1">&#39;positive&#39;</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">positive_longitudes</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">force_longitudes</span> <span class="o">==</span> <span class="s1">&#39;]-180,180]&#39;</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">longitudes_between_minus180_180</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.extract_subzone"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.extract_subzone">[docs]</a>    <span class="k">def</span> <span class="nf">extract_subzone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">subzone</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts the subzone C or CI from a LAM field.</span>

<span class="sd">        :param data: the data values with shape concording with geometry.</span>
<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only,</span>
<span class="sd">          extracts the data resp. from the C or C+I zone off the C+I(+E) zone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subzone</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;CI&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;only possible values for &#39;subzone&#39; are &#39;C&#39;&quot;</span> <span class="o">+</span>
                               <span class="s2">&quot; or &#39;CI&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;LAMzone&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;method for LAM grids only.&quot;</span><span class="p">)</span>

        <span class="n">selectionE</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># To remove E-zone</span>
        <span class="n">selectionI</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># To eventually remove I-zone</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">selectionE</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">selectionI</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">selectionE</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="n">selectionI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]:</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span>
            <span class="n">selectionE</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span>
            <span class="n">selectionI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span>
            <span class="n">selectionE</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span>
            <span class="n">selectionI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CIE&#39;</span><span class="p">:</span>
            <span class="c1"># remove E-zone</span>
            <span class="n">edata</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">selectionE</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edata</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">if</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
            <span class="c1"># remove I-zone</span>
            <span class="n">edata</span> <span class="o">=</span> <span class="n">edata</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">selectionI</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">edata</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.make_subarray_geometry"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.make_subarray_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_subarray_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">first_i</span><span class="p">,</span> <span class="n">last_i</span><span class="p">,</span>
                               <span class="n">first_j</span><span class="p">,</span> <span class="n">last_j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a modified geometry consisting in a subarray of the grid, defined</span>
<span class="sd">        by the indexes given as argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">first_i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">first_i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">last_i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">last_i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">first_j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">first_j</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">last_j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">last_j</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;first_i, last_i, first_j and last_j must be inside the geometry&quot;</span><span class="p">)</span>

        <span class="n">newgeom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;LAMzone&#39;</span> <span class="ow">in</span> <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;input_position&#39;</span> <span class="ow">in</span> <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">coords_00</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">first_i</span><span class="p">,</span> <span class="n">first_j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
            <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">input_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">coords_00</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span> <span class="k">else</span> <span class="n">coords_00</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">input_lat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">coords_00</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span> <span class="k">else</span> <span class="n">coords_00</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_lon</span>
            <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_lat</span>
        <span class="n">newgeom</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="n">last_i</span> <span class="o">-</span> <span class="n">first_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="n">last_j</span> <span class="o">-</span> <span class="n">first_j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">newgeom</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.make_subsample_geometry"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.make_subsample_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_subsample_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_x</span><span class="p">,</span> <span class="n">sample_y</span><span class="p">,</span> <span class="n">sample_z</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a sample geometry by decreasing resolution.</span>
<span class="sd">        :param sample_x: take one over &lt;sample_x&gt; points in the x direction</span>
<span class="sd">        :param sample_y: same for the y direction</span>
<span class="sd">        :param sample_z: same for the z direction</span>

<span class="sd">        CAUTION: if your grid contains non physical point, these points can be</span>
<span class="sd">        retain in subsample. Use select_zone beforehand to suppress these points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_y</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_z</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;sample_x, y and z must be integers&quot;</span>
        <span class="n">newgeom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;LAMzone&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;input_position&#39;</span> <span class="ow">in</span> <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">coords_00</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
            <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">input_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">coords_00</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span> <span class="k">else</span> <span class="n">coords_00</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">input_lat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">coords_00</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span> <span class="k">else</span> <span class="n">coords_00</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_lon</span>
            <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_lat</span>
        <span class="n">newgeom</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">newgeom</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample_x</span><span class="p">))),</span>
                              <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">newgeom</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample_y</span><span class="p">)))}</span>
        <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_x</span>
        <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newgeom</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_y</span>
        <span class="n">newgeom</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">newgeom</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">[::</span><span class="n">sample_z</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">newgeom</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.get_datashape"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.get_datashape">[docs]</a>    <span class="k">def</span> <span class="nf">get_datashape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">dimT</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">force_dimZ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the data shape according to the geometry.</span>

<span class="sd">        :param force_dimZ: if supplied, force the Z dimension instead of that</span>
<span class="sd">          of the vertical geometry</span>
<span class="sd">        :param dimT: if supplied, is the time dimension to be added to the</span>
<span class="sd">          data shape</span>
<span class="sd">        :param d4: - if True,  shape is 4D</span>
<span class="sd">                   - if False, shape has only those &gt; 1</span>
<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, informes that</span>
<span class="sd">          data is resp. on the C or C+I zone off the C+I(+E) zone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subzone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
            <span class="n">dimY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> \
                <span class="s2">&quot;*subzone* cannot be requested for this geometry&quot;</span>
            <span class="k">assert</span> <span class="n">subzone</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;CI&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CIE&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;CI&#39;</span><span class="p">:</span>
                    <span class="n">dimX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span>
                    <span class="n">dimY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                    <span class="n">dimX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span>
                    <span class="n">dimY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CI&#39;</span><span class="p">:</span>
                <span class="n">dimX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span>
                <span class="n">dimY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">force_dimZ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimZ</span> <span class="o">=</span> <span class="n">force_dimZ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimZ</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d4</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimT</span><span class="p">,</span> <span class="n">dimZ</span><span class="p">,</span> <span class="n">dimY</span><span class="p">,</span> <span class="n">dimX</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">dimT</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimT</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dimZ</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimZ</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]:</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimY</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]:</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimX</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.reshape_data"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.reshape_data">[docs]</a>    <span class="k">def</span> <span class="nf">reshape_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
                     <span class="n">first_dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 2D data (horizontal dimensions) reshaped from 1D,</span>
<span class="sd">        according to geometry.</span>

<span class="sd">        :param data: the 1D data (or 3D with a T and Z dimensions,</span>
<span class="sd">          or 2D with either a T/Z dimension, to be specified),</span>
<span class="sd">          of dimension concording with geometry. In case data is 3D, T must be</span>
<span class="sd">          first dimension and Z the second.</span>
<span class="sd">        :param first_dimension: in case data is 2D, specify what is the first</span>
<span class="sd">          dimension of data among (&#39;T&#39;, &#39;Z&#39;)</span>
<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, informes that</span>
<span class="sd">          data is resp. on the C or C+I zone off the C+I(+E) zone.</span>
<span class="sd">        :param d4: - if True,  returned values are shaped in a 4 dimensions array</span>
<span class="sd">                   - if False, shape of returned values is determined with respect to geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span>
        <span class="n">shp_in</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">nb_levels</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">nb_validities</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">first_dimension</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">),</span> \
                <span class="s2">&quot;*first_dimension* must be among (&#39;T&#39;, &#39;Z&#39;) if *data*.shape == 2&quot;</span>
            <span class="k">if</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
                <span class="n">nb_validities</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
                <span class="n">nb_levels</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">nb_validities</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nb_levels</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">nb_levels</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)),</span> \
               <span class="s2">&quot;vertical dimension of data must be 1 or self.vcoordinate.levels=&quot;</span> \
               <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d4</span> <span class="ow">or</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">nb_validities</span><span class="p">,</span> <span class="n">nb_levels</span><span class="p">):</span>  <span class="c1"># data as 4D or truly 4D</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">dimT</span><span class="o">=</span><span class="n">nb_validities</span><span class="p">,</span> <span class="n">force_dimZ</span><span class="o">=</span><span class="n">nb_levels</span><span class="p">,</span>
                                     <span class="n">d4</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">dimT</span><span class="o">=</span><span class="n">nb_validities</span><span class="p">,</span> <span class="n">force_dimZ</span><span class="o">=</span><span class="n">nb_levels</span><span class="p">,</span>
                                     <span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.horizontally_flattened"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.horizontally_flattened">[docs]</a>    <span class="k">def</span> <span class="nf">horizontally_flattened</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of *data* with horizontal dimensions flattened.</span>
<span class="sd">        *data* must be 4D for simplicity reasons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
        <span class="n">data3D</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gridpoints_number</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">data3D</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data3D</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.fill_maskedvalues"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.fill_maskedvalues">[docs]</a>    <span class="k">def</span> <span class="nf">fill_maskedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of *data* with masked values filled with *fill_value*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.gimme_corners_ij"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.gimme_corners_ij">[docs]</a>    <span class="k">def</span> <span class="nf">gimme_corners_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the indices (i, j) of the four corners of a rectangular grid,</span>
<span class="sd">        as a dict(corner=(i, j)) with corner in: \n</span>
<span class="sd">        ll = lower-left / lr = lower-right / ur = upper-right / ul = upper-left.</span>

<span class="sd">        (0, 0) is always the lower-left corner of the grid.</span>

<span class="sd">        :param subzone: for LAM fields, returns the corners of the subzone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;LAMzone&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CIE&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subzone</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;CIE&#39;</span><span class="p">):</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;CI&#39;</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">])</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">])</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CI&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subzone</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;CI&#39;</span><span class="p">):</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;ll&#39;</span><span class="p">:</span><span class="n">ll</span><span class="p">,</span> <span class="s1">&#39;lr&#39;</span><span class="p">:</span><span class="n">lr</span><span class="p">,</span> <span class="s1">&#39;ul&#39;</span><span class="p">:</span><span class="n">ul</span><span class="p">,</span> <span class="s1">&#39;ur&#39;</span><span class="p">:</span><span class="n">ur</span><span class="p">}</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.gimme_corners_ll"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.gimme_corners_ll">[docs]</a>    <span class="k">def</span> <span class="nf">gimme_corners_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the lon/lat of the four corners of a rectangular grid,</span>
<span class="sd">        as a dict(corner=(lon, lat)) with corner in: \n</span>
<span class="sd">        ll = lower-left / lr = lower-right / ur = upper-right / ul = upper-left.</span>

<span class="sd">        :param subzone: for LAM grids, returns the corners of the subzone.</span>
<span class="sd">        :param position: position of corners with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corners</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">corners</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">corners</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.minmax_ll"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.minmax_ll">[docs]</a>    <span class="k">def</span> <span class="nf">minmax_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return min/max of lon/lat.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">jmin</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ll&#39;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">imax</span><span class="p">,</span> <span class="n">jmax</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ur&#39;</span><span class="p">]</span>
        <span class="n">border</span> <span class="o">=</span> <span class="p">[(</span><span class="n">imin</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> \
                 <span class="p">[(</span><span class="n">imax</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> \
                 <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">jmin</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">imax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> \
                 <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">jmax</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">imax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">ilist</span><span class="p">,</span> <span class="n">jlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">border</span><span class="p">))</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ilist</span><span class="p">),</span>
                                  <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jlist</span><span class="p">))</span>
        <span class="n">lonmin</span><span class="p">,</span> <span class="n">lonmax</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">lons</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">latmin</span><span class="p">,</span> <span class="n">latmax</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">lats</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span> <span class="ow">in</span> <span class="p">(</span><span class="n">lonmin</span><span class="p">,</span> <span class="n">lonmax</span><span class="p">,</span> <span class="n">latmin</span><span class="p">,</span> <span class="n">latmax</span><span class="p">):</span>
            <span class="c1">#space-view geometry for example</span>
            <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)</span>
            <span class="n">lonmin</span><span class="p">,</span> <span class="n">lonmax</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">lons</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">latmin</span><span class="p">,</span> <span class="n">latmax</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">lats</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;lonmin&#39;</span><span class="p">:</span><span class="n">lonmin</span><span class="p">,</span> <span class="s1">&#39;lonmax&#39;</span><span class="p">:</span><span class="n">lonmax</span><span class="p">,</span>
                <span class="s1">&#39;latmin&#39;</span><span class="p">:</span><span class="n">latmin</span><span class="p">,</span> <span class="s1">&#39;latmax&#39;</span><span class="p">:</span><span class="n">latmax</span><span class="p">}</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.point_is_inside_domain_ll"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.point_is_inside_domain_ll">[docs]</a>    <span class="k">def</span> <span class="nf">point_is_inside_domain_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span>
                                  <span class="n">margin</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span>
                                  <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the point(s) of lon/lat coordinates is(are) inside the</span>
<span class="sd">        field.</span>

<span class="sd">        :param lon: longitude of point(s) in degrees.</span>
<span class="sd">        :param lat: latitude of point(s) in degrees.</span>
<span class="sd">        :param margin: considers the point inside if at least &#39;margin&#39; points far</span>
<span class="sd">          from the border. The -0.1 default is a safety for precision errors.</span>
<span class="sd">        :param subzone: considers only a subzone among (&#39;C&#39;, &#39;CI&#39;) of the domain.</span>
<span class="sd">        :param position: position of the grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">Xmin</span><span class="p">,</span> <span class="n">Ymin</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ll&#39;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">Xmax</span><span class="p">,</span> <span class="n">Ymax</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ur&#39;</span><span class="p">]</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Xmin</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                     <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Xmax</span> <span class="o">-</span> <span class="n">margin</span><span class="p">),</span>
                                   <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Ymin</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                     <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Ymax</span> <span class="o">-</span> <span class="n">margin</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">inside</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.point_is_inside_domain_ij"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.point_is_inside_domain_ij">[docs]</a>    <span class="k">def</span> <span class="nf">point_is_inside_domain_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">j</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">margin</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span>
                                  <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the point(s) of i/j coordinates is(are) inside the</span>
<span class="sd">        field.</span>

<span class="sd">        :param i: X index of point</span>
<span class="sd">        :param j: Y index of point.</span>
<span class="sd">        :param margin: considers the point inside if at least &#39;margin&#39; points far</span>
<span class="sd">          from the border. The -0.1 default is a safety for precision errors.</span>
<span class="sd">        :param subzone: considers only a subzone among (&#39;C&#39;, &#39;CI&#39;) of the domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;*j* is mandatory when field has a two horizontal dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;*i* is mandatory when field has one horizontal dimension&quot;</span><span class="p">)</span>

        <span class="p">(</span><span class="n">Xmin</span><span class="p">,</span> <span class="n">Ymin</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ll&#39;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">Xmax</span><span class="p">,</span> <span class="n">Ymax</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ur&#39;</span><span class="p">]</span>

        <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inside_i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Xmin</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">,</span>
                                         <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">Xmax</span> <span class="o">-</span> <span class="n">margin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inside_j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Ymin</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">,</span>
                                         <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">Ymax</span> <span class="o">-</span> <span class="n">margin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="n">inside_j</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="n">inside_i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">inside_i</span><span class="p">,</span> <span class="n">inside_j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inside</span></div>

<div class="viewcode-block" id="RectangularGridGeometry.nearest_points"><a class="viewcode-back" href="../../../library/Geometry.html#epygram.geometries.AbstractGeometry.RectangularGridGeometry.nearest_points">[docs]</a>    <span class="k">def</span> <span class="nf">nearest_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span>
                       <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">external_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">squeeze</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the (i, j) positions of the nearest points.</span>

<span class="sd">        :param lon: longitude of point in degrees.</span>
<span class="sd">        :param lat: latitude of point in degrees.</span>
<span class="sd">        :param request: criteria for selecting the points, among:</span>
<span class="sd">               * {&#39;n&#39;:&#39;1&#39;} - the nearest point</span>
<span class="sd">               * {&#39;n&#39;:&#39;2*2&#39;} - the 2*2 square points around the position</span>
<span class="sd">               * {&#39;n&#39;:&#39;4*4&#39;} - the 4*4 square points around the position</span>
<span class="sd">               * {&#39;n&#39;:&#39;N*N&#39;} - the N*N square points around the position: N must be even</span>
<span class="sd">               * {&#39;radius&#39;:xxxx, &#39;shape&#39;:&#39;square&#39;} - the points which are xxxx metres</span>
<span class="sd">                 around the position in X or Y direction</span>
<span class="sd">               * {&#39;radius&#39;:xxxx, &#39;shape&#39;:&#39;circle&#39;} - the points within xxxx metres</span>
<span class="sd">                 around the position. (default shape == circle)</span>
<span class="sd">        :param position: position in the model cell of the lat lon position.</span>
<span class="sd">               Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        :param external_distance: can be a dict containing the target point value</span>
<span class="sd">                and an external field on the same grid as self, to which the distance</span>
<span class="sd">                is computed within the 4 horizontally nearest points; e.g.</span>
<span class="sd">                {&#39;target_value&#39;:4810, &#39;external_field&#39;:a_3DField_with_same_geometry}.</span>
<span class="sd">                If so, the nearest point is selected with</span>
<span class="sd">                distance = |target_value - external_field.data|</span>
<span class="sd">                Only valid with request={&#39;n&#39;:&#39;1&#39;}</span>
<span class="sd">        :param squeeze: True to suppress useless dimensions</span>

<span class="sd">        :rtype: general output form is [list, list, ..., list]</span>
<span class="sd">                with as many list items as the length of lon/lat.</span>
<span class="sd">                Each list item is of the form [tuple, tuple, ..., tuple]</span>
<span class="sd">                with as many tuples as the request implies. A tuple</span>
<span class="sd">                represents one of the nearest points associated with one</span>
<span class="sd">                value taken from lon/lat. Each tuple as the form</span>
<span class="sd">                (i, j).</span>

<span class="sd">                Dimensions with a length of one are removed except if</span>
<span class="sd">                squeeze is False. If squeeze is True and if request</span>
<span class="sd">                implies only one nearest point, the list item of the general</span>
<span class="sd">                output form is replaced by the tuple item; if length of</span>
<span class="sd">                lon/lat is one, the output is directly the list item of</span>
<span class="sd">                the general output form. Hence, if length of lon/lat is</span>
<span class="sd">                one and the request implies only one point, the output is</span>
<span class="sd">                a tuple.</span>

<span class="sd">                In case of a simple square request, output is actually</span>
<span class="sd">                an array. Otherwise, the output is as described (it cannot</span>
<span class="sd">                be an array because the number of nearest points can vary</span>
<span class="sd">                with the entry point).</span>

<span class="sd">        In case of a {&#39;n&#39;:&#39;2*2&#39;} request, order of points obtained on a rectangular grid is</span>
<span class="sd">        (and must be) such that first and second point share the i position (hence</span>
<span class="sd">        third and forth point also share the i position) and first and third share the j</span>
<span class="sd">        position (hence the second and forth also share the j position).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_is_inside_domain_ll</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;point (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">+</span>
                             <span class="s2">&quot;) is out of field domain.&quot;</span><span class="p">)</span>

        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">j0</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="n">i_int</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="n">j_int</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">j0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="n">nsquare_match</span> <span class="o">=</span> <span class="n">_re_nearest_sq</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nsquare_match</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">),</span> \
                <span class="s2">&quot;anisotropic request {&#39;n&#39;:&#39;N*M&#39;} is not supported.&quot;</span>
        <span class="k">if</span> <span class="n">external_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">request</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="s1">&#39;1&#39;</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">_increments</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;academic&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">i_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;academic&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">j_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">i_incr</span><span class="p">,</span> <span class="n">j_incr</span><span class="p">)</span>

        <span class="c1"># compute points position</span>
        <span class="k">if</span> <span class="n">request</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="s1">&#39;1&#39;</span><span class="p">}</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">external_distance</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">),</span>
                       <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">j0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># square: size</span>
            <span class="k">if</span> <span class="n">external_distance</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">):</span>
                <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">resolution</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nsquare_match</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;unrecognized **request**: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">request</span><span class="p">))</span>
            <span class="c1"># square: indexes</span>
            <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">)</span> <span class="o">=</span> <span class="n">_increments</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">i_int</span> <span class="o">+</span> <span class="n">di</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">]</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="p">[</span><span class="n">j_int</span> <span class="o">+</span> <span class="n">dj</span> <span class="k">for</span> <span class="n">dj</span> <span class="ow">in</span> <span class="n">jj</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jj</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># filter: if external distance</span>
            <span class="k">if</span> <span class="n">external_distance</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># We transform into list to be able to modify the length</span>
                <span class="k">for</span> <span class="n">ipt</span><span class="p">,</span> <span class="n">points</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                    <span class="n">mindistance</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">external_distance</span><span class="p">[</span><span class="s1">&#39;external_field&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getvalue_ij</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">one</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="n">external_distance</span><span class="p">[</span><span class="s1">&#39;target_value&#39;</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">mindistance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">mindistance</span><span class="p">:</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
                            <span class="n">mindistance</span> <span class="o">=</span> <span class="n">dist</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># all item must now have the same length</span>

        <span class="c1"># filter: if radius</span>
        <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># We transform into list to be able to modify the length</span>
            <span class="k">for</span> <span class="n">ipt</span><span class="p">,</span> <span class="n">points</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;circle&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;circle&#39;</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">points</span>
                                   <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">((</span><span class="n">lon</span><span class="p">[</span><span class="n">ipt</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">ipt</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;square&#39;</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">points</span>
                                   <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="n">lon</span><span class="p">[</span><span class="n">ipt</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">ipt</span><span class="p">]))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)))</span> <span class="o">&lt;=</span> <span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">])]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;no points found: radius may be too small.&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_is_inside_domain_ij</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]))):</span>
                    <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;one point (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">+</span>
                                       <span class="s2">&quot;) too close to field domain borders.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">squeeze</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># check all points in domain</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_is_inside_domain_ij</span><span class="p">(</span><span class="o">*</span><span class="n">point</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;one point (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">+</span>
                                       <span class="s2">&quot;) too close to field domain borders.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span> <span class="nf">_what_grid_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
                              <span class="n">arpifs_var_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">spectral_geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the grid &amp; dimensions of the field.</span>

<span class="sd">        :param out: the output open file-like object</span>
<span class="sd">        :param arpifs_var_names: if True, prints the equivalent &#39;arpifs&#39; variable</span>
<span class="sd">          names.</span>
<span class="sd">        :param spectral_geometry: an optional dict containing the spectral</span>
<span class="sd">          truncatures {&#39;in_X&#39;:, &#39;in_Y&#39;:}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">if</span> <span class="s1">&#39;LAMzone&#39;</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">:</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Zone&quot;</span><span class="p">,</span> <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NDLON)&#39;</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Total points in X&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                            <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NDGL)&#39;</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Total points in Y&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                            <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CIE&#39;</span><span class="p">:</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Points of C+I in X&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">])</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Points of C+I in Y&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NDLUN-1)&#39;</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                                <span class="s2">&quot;Low-left X offset for I zone&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NDGUN-1)&#39;</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                                <span class="s2">&quot;Low-left Y offset for I zone&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">])</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Width of I strip in X&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Width of I strip in Y&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CI&#39;</span><span class="p">:</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Width of I strip in X&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Width of I strip in Y&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">spectral_geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NMSMAX)&#39;</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Truncation in X&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                                <span class="n">spectral_geometry</span><span class="p">[</span><span class="s1">&#39;in_X&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NSMAX)&#39;</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Truncation in Y&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                                <span class="n">spectral_geometry</span><span class="p">[</span><span class="s1">&#39;in_Y&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NDLON)&#39;</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Total points in X&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                            <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Total points in Y&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                            <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">separation_line</span><span class="p">)</span>

    <span class="c1">#FIXME: cleanme def __eq__(self, other):</span>
    <span class="c1">#    &quot;&quot;&quot;Test of equality by recursion on the object&#39;s attributes.&quot;&quot;&quot;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;    if self.__class__ == other.__class__ and \</span>
<span class="sd">           set(self._attributes.keys()) == set(other._attributes.keys()):</span>
<span class="sd">            for attr in self._attributes.keys():</span>
<span class="sd">                if attr == &#39;grid&#39;:</span>
<span class="sd">                    # the same grid could be defined from different inputs</span>
<span class="sd">                    selfgrid = {k:v for k, v in self.grid.items() if</span>
<span class="sd">                                k not in [&#39;input_lon&#39;,</span>
<span class="sd">                                          &#39;input_lat&#39;,</span>
<span class="sd">                                          &#39;input_position&#39;]}</span>
<span class="sd">                    othergrid = {k:v for k, v in self.grid.items() if</span>
<span class="sd">                                 k not in [&#39;input_lon&#39;,</span>
<span class="sd">                                           &#39;input_lat&#39;,</span>
<span class="sd">                                           &#39;input_position&#39;]}</span>
<span class="sd">                    ok = (selfgrid == othergrid and</span>
<span class="sd">                          self.getcenter() == other.getcenter())</span>
<span class="sd">                else:</span>
<span class="sd">                    ok = self._attributes[attr] == other._attributes[attr]</span>
<span class="sd">                if not ok:</span>
<span class="sd">                    break</span>
<span class="sd">        else:</span>
<span class="sd">            ok = False</span>
<span class="sd">        return ok</span>

<span class="sd">    def __hash__(self):</span>
<span class="sd">        # known issue __eq__/must be defined both or none, else inheritance is broken</span>
<span class="sd">        return super(RectangularGridGeometry, self).__hash__()&quot;&quot;&quot;</span></div>


<span class="k">class</span> <span class="nc">LLGeometry</span><span class="p">(</span><span class="n">RectangularGridGeometry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles the geometry for a Regular Lon/Lat 3-Dimensions Field.</span>
<span class="sd">    Abstract.</span>

<span class="sd">    TODO: Is this class really necessary. Maybe we could make only one class</span>
<span class="sd">          with LLGeometry, RegLLGeometry and RotLLGEometry?</span>
<span class="sd">          Is a RegLLGeometry equivalent to a RotLLGeometry with a null rotation angle?</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isglobal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: True if geometry is global</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">360.</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">180.</span>

    <span class="k">def</span> <span class="nf">tolerant_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">epsilon</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="c1"># create copies of inner objects to filter some ghost attributes</span>
            <span class="n">almost_self</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                           <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ghost_attributes</span><span class="p">}</span>
            <span class="n">almost_other</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_ghost_attributes</span><span class="p">}</span>
            <span class="c1"># (the same grid could be defined from different inputs)</span>
            <span class="k">for</span> <span class="n">almost</span> <span class="ow">in</span> <span class="p">(</span><span class="n">almost_self</span><span class="p">,</span> <span class="n">almost_other</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;input_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;input_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;input_position&#39;</span><span class="p">):</span>
                    <span class="n">almost</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">almost_self</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getcenter</span><span class="p">()</span>
            <span class="n">almost_other</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">getcenter</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Comparator</span><span class="o">.</span><span class="n">are_equal</span><span class="p">(</span><span class="n">almost_self</span><span class="p">,</span> <span class="n">almost_other</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">global_shift_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">longitude_shift</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shifts the center of the geometry by *longitude_shift* (in degrees).</span>
<span class="sd">        *longitude_shift* has to be a multiple of the grid&#39;s resolution in</span>
<span class="sd">        longitude.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ll</span><span class="p">()</span>
        <span class="n">zip_width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ul&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">))</span>
        <span class="n">zip_minus_resolution</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">zip_width</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                                     <span class="n">_rd</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zip_minus_resolution</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
            <span class="n">as_int</span> <span class="o">=</span> <span class="mf">1e6</span>  <span class="c1"># decimal error</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">longitude_shift</span> <span class="o">*</span> <span class="n">as_int</span><span class="p">)</span> <span class="o">%</span>
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">as_int</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">config</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">((</span><span class="s2">&quot;*longitude_shift* (</span><span class="si">{}</span><span class="s2">) has to be a multiple&quot;</span> <span class="o">+</span>
                                    <span class="s2">&quot; of the grid&#39;s resolution in longitude (</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="p">)</span><span class="o">.</span>
                                   <span class="nb">format</span><span class="p">(</span><span class="n">longitude_shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">longitude_shift</span><span class="p">,</span>
                                     <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">longitude_shift</span><span class="p">,</span>
                                           <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;unable to shift center if &quot;</span> <span class="o">+</span>
                               <span class="s2">&quot;lon_max - lon_min != X_resolution&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns evenly spaced points over the specified interval.</span>
<span class="sd">        Points are lined up in the geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param num: number of points, including point1 and point2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;num&#39; must be at least 2.&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">)</span>
        <span class="n">xy_linspace</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">),</span>
                               <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">)))</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xy2ll</span><span class="p">(</span><span class="o">*</span><span class="n">xy</span><span class="p">)</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">xy_linspace</span><span class="p">]</span>

    <span class="nd">@_need_pyproj_geod</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the distance between two points along a straight line in the</span>
<span class="sd">        geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>

<span class="sd">        Warning: requires the :mod:`pyproj` module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plast</span> <span class="o">=</span> <span class="n">end1</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">distance</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">plast</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plast</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">plast</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">return</span> <span class="n">distance</span>

    <span class="k">def</span> <span class="nf">make_zoom_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">extra_10th</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new geometry with the points contained in *zoom*.</span>

<span class="sd">        :param zoom: a dict(lonmin=, lonmax=, latmin=, latmax=).</span>
<span class="sd">        :param extra_10th: if True, add 1/10th of the X/Y extension of the zoom</span>
<span class="sd">                           (only usefull for the regular_lonlat grid implementation).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs_zoomgeom</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vcoordinate&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(),</span>
                           <span class="s1">&#39;position_on_horizontal_grid&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">position_on_horizontal_grid</span><span class="p">,</span>
                           <span class="s1">&#39;geoid&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">extra_10th</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmax&#39;</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">-</span>
                  <span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmin&#39;</span><span class="p">],</span> <span class="mf">0.</span><span class="p">))</span> <span class="o">/</span> <span class="mf">10.</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmax&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmin&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">10.</span>
            <span class="n">zoom</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lonmin&#39;</span><span class="p">:</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmin&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span>
                    <span class="s1">&#39;lonmax&#39;</span><span class="p">:</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmax&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span>
                    <span class="s1">&#39;latmin&#39;</span><span class="p">:</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmin&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">dy</span><span class="p">,</span>
                    <span class="s1">&#39;latmax&#39;</span><span class="p">:</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmax&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span><span class="p">}</span>
        <span class="n">imin</span><span class="p">,</span> <span class="n">jmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmin&#39;</span><span class="p">],</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmin&#39;</span><span class="p">])</span>
        <span class="n">imax</span><span class="p">,</span> <span class="n">jmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmax&#39;</span><span class="p">],</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmax&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">imin</span> <span class="o">&gt;</span> <span class="n">imax</span><span class="p">:</span>
            <span class="n">gridmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ll</span><span class="p">()[</span><span class="s1">&#39;ll&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">diff_lonmin</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridmin</span> <span class="o">-</span> <span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmin&#39;</span><span class="p">],</span>
                                                         <span class="n">gridmin</span><span class="p">))</span>
            <span class="n">Xres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff_lonmin</span> <span class="o">//</span> <span class="n">Xres</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Xres</span>
            <span class="n">shifted_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">shifted_self</span><span class="o">.</span><span class="n">global_shift_center</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">shifted_self</span><span class="o">.</span><span class="n">make_zoom_geometry</span><span class="p">(</span><span class="n">zoom</span><span class="p">,</span> <span class="n">extra_10th</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># zoom already includes the extra part</span>
        <span class="k">elif</span> <span class="n">imin</span> <span class="o">==</span> <span class="n">imax</span><span class="p">:</span>  <span class="c1"># means 360deg wide</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">imin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">imin</span><span class="p">)),</span>
                   <span class="mi">0</span><span class="p">)</span>
        <span class="n">imax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">imax</span><span class="p">)),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">jmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">jmin</span><span class="p">)),</span>
                   <span class="mi">0</span><span class="p">)</span>
        <span class="n">jmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">jmax</span><span class="p">)),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="n">imax</span> <span class="o">-</span> <span class="n">imin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                         <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="n">jmax</span> <span class="o">-</span> <span class="n">jmin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
        <span class="n">lonmin</span><span class="p">,</span> <span class="n">latmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">jmin</span><span class="p">)</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;input_position&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                   <span class="s1">&#39;input_lon&#39;</span><span class="p">:</span><span class="n">Angle</span><span class="p">(</span><span class="n">lonmin</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                                   <span class="s1">&#39;input_lat&#39;</span><span class="p">:</span><span class="n">Angle</span><span class="p">(</span><span class="n">latmin</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                                   <span class="s1">&#39;X_resolution&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">],</span>
                                   <span class="s1">&#39;Y_resolution&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">RegLLGeometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_zoomgeom</span><span class="p">)</span> <span class="c1">#FIXME why necessarily a regular and not a rotated?</span>

    <span class="k">def</span> <span class="nf">resolution_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local resolution at the nearest point of lon/lat.</span>
<span class="sd">        It&#39;s the distance between this point and its closest neighbour.</span>

<span class="sd">        :param lon: longitude of the point in degrees</span>
<span class="sd">        :param lat: latitude of the point in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ij</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">resolution_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance to the nearest point of (i,j) point.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">iint</span><span class="p">,</span> <span class="n">jint</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">),</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>
        <span class="n">points_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">iint</span> <span class="o">+</span> <span class="n">oi</span><span class="p">,</span> <span class="n">jint</span> <span class="o">+</span> <span class="n">oj</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">oi</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">oj</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                       <span class="k">if</span> <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">iint</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points_list</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">plane_azimuth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initial bearing from *end1* to *end2* points in plane local referential</span>
<span class="sd">        geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">))</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.</span> <span class="o">-</span> <span class="mf">180.</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">epygram 1.5.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../epygram.html" >epygram</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../geometries.html" >epygram.geometries</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">epygram.geometries.AbstractGeometry</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014 --- 2024, A.Mary, S.Riette.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>