
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>epygram.geometries.GaussGeometry &#8212; epygram 1.5.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinxdoc.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">epygram 1.5.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../epygram.html" >epygram</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../geometries.html" accesskey="U">epygram.geometries</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">epygram.geometries.GaussGeometry</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for epygram.geometries.GaussGeometry</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Copyright (c) Météo France (2014-)</span>
<span class="c1"># This software is governed by the CeCILL-C license under French law.</span>
<span class="c1"># http://www.cecill.info</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Contains the classes for 3D geometries of fields.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">import</span> <span class="nn">footprints</span>
<span class="kn">from</span> <span class="nn">footprints</span> <span class="kn">import</span> <span class="n">proxy</span> <span class="k">as</span> <span class="n">fpx</span>
<span class="kn">from</span> <span class="nn">bronx.syntax.arrays</span> <span class="kn">import</span> <span class="n">stretch_array</span>

<span class="kn">from</span> <span class="nn">epygram</span> <span class="kn">import</span> <span class="n">epygramError</span><span class="p">,</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">epygram.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">degrees_nearest_mod</span><span class="p">,</span> <span class="n">Angle</span><span class="p">,</span>
                          <span class="n">positive_longitudes</span><span class="p">,</span> <span class="n">longitudes_between_minus180_180</span><span class="p">,</span>
                          <span class="n">write_formatted</span><span class="p">,</span>
                          <span class="n">nearlyEqual</span><span class="p">,</span>
                          <span class="n">as_numpy_array</span><span class="p">,</span> <span class="n">moveaxis</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.VGeometry</span> <span class="kn">import</span> <span class="n">VGeometry</span>
<span class="kn">from</span> <span class="nn">.AbstractGeometry</span> <span class="kn">import</span> <span class="n">Geometry</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_need_pyproj_geod</span>

<span class="n">epylog</span> <span class="o">=</span> <span class="n">footprints</span><span class="o">.</span><span class="n">loggers</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">_re_nearest_sq</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(?P&lt;n&gt;\d+)\*(?P&lt;m&gt;\d+)&#39;</span><span class="p">)</span>



<div class="viewcode-block" id="GaussGeometry"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry">[docs]</a><span class="k">class</span> <span class="nc">GaussGeometry</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles the geometry for a Global Gauss grid 3-Dimensions Field.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_ghost_attributes</span> <span class="o">=</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">_ghost_attributes</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;_buffered_gauss_grid&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">vcoordinate</span><span class="p">,</span>
                 <span class="n">position_on_horizontal_grid</span><span class="o">=</span><span class="s1">&#39;__unknown__&#39;</span><span class="p">,</span> <span class="n">geoid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: Name of geometrical type of representation of points on the Globe.</span>
<span class="sd">                     Name must be among [&#39;rotated_reduced_gauss&#39;, &#39;reduced_gauss&#39;, &#39;regular_gauss&#39;</span>
<span class="sd">        :param grid: Handles description of the horizontal grid.</span>
<span class="sd">        :param dimensions: Handles grid dimensions.</span>
<span class="sd">        :param vcoordinate: Handles vertical geometry parameters.</span>
<span class="sd">        :param position_on_horizontal_grid: Position of points w/r to the horizontal.</span>
<span class="sd">                                            among: [&#39;upper-right&#39;, &#39;upper-left&#39;,</span>
<span class="sd">                                                    &#39;lower-left&#39;, &#39;lower-right&#39;,</span>
<span class="sd">                                                    &#39;center-left&#39;, &#39;center-right&#39;,</span>
<span class="sd">                                                    &#39;lower-center&#39;, &#39;upper-center&#39;,</span>
<span class="sd">                                                    &#39;center&#39;, &#39;__unknown__&#39;]</span>
<span class="sd">        :param geoid: To specify geoid shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_attr_inlist</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">,</span> <span class="s1">&#39;reduced_gauss&#39;</span><span class="p">,</span> <span class="s1">&#39;regular_gauss&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">GaussGeometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">vcoordinate</span><span class="p">,</span>
                                            <span class="n">position_on_horizontal_grid</span><span class="p">,</span> <span class="n">geoid</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isglobal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: True if geometry is global</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_consistency_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check that the geometry is consistent.&quot;&quot;&quot;</span>
        <span class="n">grid_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">,</span> <span class="s1">&#39;latitudes&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">:</span>
            <span class="n">grid_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;pole_lat&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;grid attribute must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">Angle</span><span class="p">),</span> \
            <span class="s2">&quot;&#39;latitudes&#39; attribute of grid must be a list of Angle objects.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
        <span class="n">dimensions_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;max_lon_number&#39;</span><span class="p">,</span> <span class="s1">&#39;lat_number&#39;</span><span class="p">,</span> <span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;dimensions attribute must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_reduced_gauss&#39;</span> \
           <span class="ow">and</span> <span class="n">nearlyEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span> <span class="mf">0.</span><span class="p">)</span> \
           <span class="ow">and</span> <span class="n">nearlyEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span> <span class="mf">90.</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;reduced_gauss&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">suggested_GRIB2_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectral</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s1">&#39;H2D&#39;</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">:</span><span class="s1">&#39;reduced_rotated_gg&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;reduced_gauss&#39;</span><span class="p">:</span><span class="s1">&#39;reduced_gg&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;regular_gauss&#39;</span><span class="p">:</span><span class="s1">&#39;regular_gg&#39;</span><span class="p">}[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_GRIB2_sample</span><span class="p">(</span><span class="s1">&#39;sh&#39;</span> <span class="k">if</span> <span class="n">spectral</span> <span class="k">else</span> <span class="n">prefix</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="GaussGeometry.ij2ll"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.ij2ll">[docs]</a>    <span class="k">def</span> <span class="nf">ij2ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (lon, lat) coordinates of point *(i,j)*, in degrees.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;horizontal staggered grids for reduced</span><span class="se">\</span>
<span class="s2">                                       gauss grid are not implemented.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span>\
           <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">latitudes</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">]))])</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">latitudes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">/</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

        <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_stretch</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span></div>

<div class="viewcode-block" id="GaussGeometry.ll2ij"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.ll2ij">[docs]</a>    <span class="k">def</span> <span class="nf">ll2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (*i, j*) coordinates in the 2D matrix of gridpoints,</span>
<span class="sd">        of the gridpoint nearest to (*lon*, *lat*).</span>

<span class="sd">        :param lon: longitude of point in degrees</span>
<span class="sd">        :param lat: latitude of point in degrees</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">ij</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nearest_points</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">},</span> <span class="n">position</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ij</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ij</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_allocate_colocation_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compressed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_float</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the array for lonlat grid.</span>
<span class="sd">        Just a trick to avoid recomputing the array for several fields that</span>
<span class="sd">        share their geometry.</span>

<span class="sd">        :param compressed: if True, return 1D arrays, else 2D masked arrays.</span>
<span class="sd">        :param as_float: if True, return arrays with dtype float64, else int64.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Jmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]</span>
        <span class="n">Imax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">]</span>
        <span class="n">igrid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">jgrid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Jmax</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Imax</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                <span class="n">igrid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">jgrid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">as_float</span><span class="p">:</span>
            <span class="n">igrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">jgrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jgrid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">igrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">igrid</span><span class="p">)</span>
            <span class="n">jgrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jgrid</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">compressed</span><span class="p">:</span>
            <span class="n">igrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">igrid</span><span class="p">)</span>
            <span class="n">jgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">jgrid</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clear_buffered_gauss_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes the buffered lonlat grid if any.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_buffered_gauss_grid&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gridpoints_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of gridpoints of the grid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="GaussGeometry.get_lonlat_grid"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.get_lonlat_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_lonlat_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">nb_validities</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">force_longitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of two tables containing one the longitude of each</span>
<span class="sd">        point, the other the latitude, with 2D shape.</span>

<span class="sd">        Shape of 2D data in Gauss grids: \n</span>
<span class="sd">          - grid[0, 0:Nj] is first (Northern) band of latitude, masked after</span>
<span class="sd">            Nj = number of longitudes for latitude j \n</span>
<span class="sd">          - grid[-1, 0:Nj] is last (Southern) band of latitude (idem).</span>

<span class="sd">        :param position: position of lonlat grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        :param d4: - if True,  returned values are shaped in a 4 dimensions array</span>
<span class="sd">                   - if False, shape of returned values is determined with respect to geometry.</span>
<span class="sd">                      d4=True requires nb_validities &gt; 0</span>
<span class="sd">        :param nb_validities: number of validities represented in data values</span>
<span class="sd">        :param force_longitudes: if &#39;positive&#39;, the longitudes will be forced positive</span>
<span class="sd">                                 if &#39;]-180,180]&#39;, the longitudes will be in the ]-180, 180] interval</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># !!! **_ enables the method to receive arguments specific to</span>
        <span class="c1">#     other geometries but useless here ! Do not remove.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_buffered_gauss_grid&#39;</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;filled&#39;</span><span class="p">):</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">]</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allocate_colocation_grid</span><span class="p">(</span><span class="n">compressed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                            <span class="n">as_float</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">FA_buffered_gauss_grid</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_buffered_gauss_grid&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lons&#39;</span><span class="p">:</span><span class="n">lons</span><span class="p">,</span> <span class="s1">&#39;lats&#39;</span><span class="p">:</span><span class="n">lats</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># trick: the arrays remain pointers to where they were</span>
                    <span class="c1"># created, so that they can be shared by several geometry</span>
                    <span class="c1"># objects or fields !</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">lats</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;filled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">d4</span><span class="p">:</span>
            <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_lonlat_4d</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">nb_validities</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">d4</span> <span class="ow">and</span> <span class="n">nb_validities</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;*nb_validities* must be 0 when d4==False&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">force_longitudes</span> <span class="o">==</span> <span class="s1">&#39;positive&#39;</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">positive_longitudes</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">force_longitudes</span> <span class="o">==</span> <span class="s1">&#39;]-180,180]&#39;</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">longitudes_between_minus180_180</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span></div>

<div class="viewcode-block" id="GaussGeometry.get_datashape"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.get_datashape">[docs]</a>    <span class="k">def</span> <span class="nf">get_datashape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_dimZ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the data shape according to the geometry.</span>

<span class="sd">        :param force_dimZ: if supplied, force the Z dimension instead of that</span>
<span class="sd">          of the vertical geometry</span>
<span class="sd">        :param dimT: if supplied, is the time dimension to be added to the</span>
<span class="sd">          data shape</span>
<span class="sd">        :param d4: - if True,  shape is 4D (need to specify *dimT*)</span>
<span class="sd">                   - if False, shape is 3D if dimZ &gt; 1 else 2D</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]</span>
        <span class="n">dimX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;max_lon_number&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">force_dimZ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimZ</span> <span class="o">=</span> <span class="n">force_dimZ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimZ</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d4</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">dimT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> \
                <span class="s2">&quot;*dimT* must be supplied with *d4*=True&quot;</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimT</span><span class="p">,</span> <span class="n">dimZ</span><span class="p">,</span> <span class="n">dimY</span><span class="p">,</span> <span class="n">dimX</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">dimZ</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimZ</span><span class="p">)</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimY</span><span class="p">)</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimX</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="GaussGeometry.reshape_data"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.reshape_data">[docs]</a>    <span class="k">def</span> <span class="nf">reshape_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">first_dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 2D data (horizontal dimensions) reshaped from 1D,</span>
<span class="sd">        according to geometry.</span>

<span class="sd">        :param data: the 1D data (or 3D with a T and Z dimensions,</span>
<span class="sd">          or 2D with either a T/Z dimension, to be specified),</span>
<span class="sd">          of dimension concording with geometry. In case data is 3D, T must be</span>
<span class="sd">          first dimension and Z the second.</span>
<span class="sd">        :param first_dimension: in case data is 2D, specify what is the first</span>
<span class="sd">          dimension of data among (&#39;T&#39;, &#39;Z&#39;)</span>
<span class="sd">        :param d4: - if True,  returned values are shaped in a 4 dimensions array</span>
<span class="sd">                   - if False, shape of returned values is determined with respect to geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span>
        <span class="n">shp_in</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">nb_levels</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">nb_validities</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">first_dimension</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">),</span> \
                <span class="s2">&quot;*first_dimension* must be among (&#39;T&#39;, &#39;Z&#39;) if *data*.shape == 2&quot;</span>
            <span class="k">if</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
                <span class="n">nb_validities</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
                <span class="n">nb_levels</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">nb_validities</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nb_levels</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">nb_levels</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)),</span> \
               <span class="s2">&quot;vertical dimension of data must be 1 or self.vcoordinate.levels=&quot;</span> <span class="o">+</span> \
               <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">shp4D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">dimT</span><span class="o">=</span><span class="n">nb_validities</span><span class="p">,</span> <span class="n">force_dimZ</span><span class="o">=</span><span class="n">nb_levels</span><span class="p">,</span> <span class="n">d4</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data4D</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_all</span><span class="p">(</span><span class="n">shp4D</span><span class="p">)</span>
        <span class="n">ind_end</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]):</span>
            <span class="n">ind_begin</span> <span class="o">=</span> <span class="n">ind_end</span>
            <span class="n">ind_end</span> <span class="o">=</span> <span class="n">ind_begin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">buff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">ind_begin</span><span class="p">,</span> <span class="n">ind_end</span><span class="p">)]</span>
                <span class="n">data4D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">])]</span> <span class="o">=</span> <span class="n">buff</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">buff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ind_begin</span><span class="p">,</span> <span class="n">ind_end</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">nb_levels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">data4D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">])]</span> <span class="o">=</span> <span class="n">buff</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data4D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">])]</span> <span class="o">=</span> <span class="n">buff</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">buff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ind_begin</span><span class="p">,</span> <span class="n">ind_end</span><span class="p">)]</span>
                <span class="n">data4D</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">])]</span> <span class="o">=</span> <span class="n">buff</span>
        <span class="k">if</span> <span class="n">ind_end</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;data have a wrong length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d4</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">data_out</span> <span class="o">=</span> <span class="n">data4D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data_out</span> <span class="o">=</span> <span class="n">data4D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
                    <span class="n">data_out</span> <span class="o">=</span> <span class="n">data4D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="k">elif</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
                    <span class="n">data_out</span> <span class="o">=</span> <span class="n">data4D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">data_out</span></div>

<div class="viewcode-block" id="GaussGeometry.fill_maskedvalues"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.fill_maskedvalues">[docs]</a>    <span class="k">def</span> <span class="nf">fill_maskedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of *data* with &#39;real&#39; masked values (i.e. not those</span>
<span class="sd">        linked to reduced Gauss) filled with *fill_value*.</span>
<span class="sd">        *data* must be already 4D for simplicity reasons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
        <span class="n">data_filled</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_filled</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]):</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i0</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">data_filled</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="n">data_filled</span></div>

<div class="viewcode-block" id="GaussGeometry.horizontally_flattened"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.horizontally_flattened">[docs]</a>    <span class="k">def</span> <span class="nf">horizontally_flattened</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of *data* with horizontal dimensions flattened and</span>
<span class="sd">        compressed (cf. numpy.ma.masked_array.compressed).</span>
<span class="sd">        *data* must be 4D for simplicity reasons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">)</span>
        <span class="n">data3D</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gridpoints_number</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">data3D</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data3D</span></div>

<div class="viewcode-block" id="GaussGeometry.resolution_ll"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.resolution_ll">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average meridian resolution (worst directional resolution)</span>
<span class="sd">        at point position.</span>

<span class="sd">        :param lon: longitude of the point in degrees</span>
<span class="sd">        :param lat: latitude of the point in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_j</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="GaussGeometry.meridian_resolution_j"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.meridian_resolution_j">[docs]</a>    <span class="k">def</span> <span class="nf">meridian_resolution_j</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average meridian resolution at longitude circle number *j*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="n">jm1</span> <span class="o">=</span> <span class="n">jint</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">jp1</span> <span class="o">=</span> <span class="n">jint</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">jm1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jp1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">jp1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jm1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jp1</span><span class="p">))</span> <span class="o">+</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jm1</span><span class="p">)))</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="k">return</span> <span class="n">dist</span></div>

<div class="viewcode-block" id="GaussGeometry.zonal_resolution_j"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.zonal_resolution_j">[docs]</a>    <span class="k">def</span> <span class="nf">zonal_resolution_j</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average zonal resolution at longitude circle number j.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">jint</span><span class="p">))</span></div>

    <span class="nd">@_need_pyproj_geod</span>
    <span class="k">def</span> <span class="nf">resolution_field_from_stretching</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a field which values are the local resolution computed as the</span>
<span class="sd">        nominal resolution stretched locally by the map factor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">sphere</span><span class="p">,</span> <span class="s2">&quot;Method is not available with a non-spheroid geoid.&quot;</span>
        <span class="n">zonal_equatorial_resolution</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">a</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;max_lon_number&#39;</span><span class="p">]</span>
        <span class="n">mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_factor_field</span><span class="p">()</span>
        <span class="n">mf</span><span class="o">.</span><span class="n">fid</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;resolution_from_stretching&#39;</span>
        <span class="n">mf</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="n">zonal_equatorial_resolution</span> <span class="o">/</span> <span class="n">mf</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mf</span>

<div class="viewcode-block" id="GaussGeometry.resolution_j"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.resolution_j">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_j</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average meridian resolution at longitude circle number j.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meridian_resolution_j</span><span class="p">(</span><span class="n">j</span><span class="p">)</span></div>

<div class="viewcode-block" id="GaussGeometry.resolution_field"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.resolution_field">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;meridian&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a field whose values are the local resolution in m.</span>

<span class="sd">        :param direction: among (&#39;zonal&#39;, &#39;meridian&#39;), direction in which</span>
<span class="sd">                          the resolution is computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;zonal&#39;</span><span class="p">,</span> <span class="s1">&#39;meridian&#39;</span><span class="p">)</span>
        <span class="n">resolutions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span> <span class="o">+</span> <span class="s1">&#39;_resolution_j&#39;</span><span class="p">)(</span><span class="n">j</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">])]</span>
        <span class="n">resol_2d</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">resolutions</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">resol_2d</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;H2D&#39;</span><span class="p">,</span>
                      <span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">fid</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span><span class="n">direction</span> <span class="o">+</span> <span class="s1">&#39; resolution&#39;</span><span class="p">},</span>
                      <span class="n">units</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="n">resol_2d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span></div>

<div class="viewcode-block" id="GaussGeometry.distance_to_nearest_neighbour_ll"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.distance_to_nearest_neighbour_ll">[docs]</a>    <span class="k">def</span> <span class="nf">distance_to_nearest_neighbour_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local resolution at the nearest point of lon/lat.</span>
<span class="sd">        It&#39;s the distance between this point and its closest neighbour.</span>

<span class="sd">        :param lon: longitude of the point in degrees</span>
<span class="sd">        :param lat: latitude of the point in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_nearest_neighbour_ij</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span></div>

<div class="viewcode-block" id="GaussGeometry.distance_to_nearest_neighbour_ij"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.distance_to_nearest_neighbour_ij">[docs]</a>    <span class="k">def</span> <span class="nf">distance_to_nearest_neighbour_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance to the nearest point of (i,j) point</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: not sure this is exactly computed</span>
        <span class="p">(</span><span class="n">iint</span><span class="p">,</span> <span class="n">jint</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">),</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>
        <span class="n">points_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">oi</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">oj</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">oj</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">pi</span> <span class="o">=</span> <span class="n">iint</span> <span class="o">+</span> <span class="n">oi</span>
                    <span class="n">pj</span> <span class="o">=</span> <span class="n">jint</span> <span class="o">+</span> <span class="n">oj</span>
                    <span class="k">if</span> <span class="n">pj</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">pj</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">pi</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">pj</span><span class="p">]</span>
                        <span class="n">points_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pi</span><span class="p">,</span> <span class="n">pj</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">iint</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points_list</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>

<div class="viewcode-block" id="GaussGeometry.point_is_inside_domain_ll"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.point_is_inside_domain_ll">[docs]</a>    <span class="k">def</span> <span class="nf">point_is_inside_domain_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">**</span><span class="n">__</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the point(s) of lon/lat coordinates is(are) inside the</span>
<span class="sd">        field.</span>
<span class="sd">        This is always the case in Gauss grids, no real meaning.</span>

<span class="sd">        :param lon: longitude of the point in degrees</span>
<span class="sd">        :param lat: latitude of the point in degrees</span>
<span class="sd">        :param margin: considers the point inside if at least &#39;margin&#39; points far</span>
<span class="sd">          from the border. The -0.1 default is a safety for precision errors.</span>
<span class="sd">        :param position: position of the grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="GaussGeometry.point_is_inside_domain_ij"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.point_is_inside_domain_ij">[docs]</a>    <span class="k">def</span> <span class="nf">point_is_inside_domain_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">margin</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the point(s) of lon/lat coordinates is(are) inside the</span>
<span class="sd">        field.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param margin: DEPRECATED</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="n">i</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="n">j</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])</span>
        <span class="c1"># Firstly we test the validity of j.</span>
        <span class="c1"># In case j is invalid result will be False</span>
        <span class="c1"># but we need a valid value for j to test the i validity</span>
        <span class="n">j2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>
                                                     <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]),</span>
                                   <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>
                                                     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">j2</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">inside</span></div>

    <span class="k">def</span> <span class="nf">_rotate_stretch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used to transform true lon/lat into</span>
<span class="sd">        rotated and stretched lon/lat.</span>

<span class="sd">        :param lon: longitude in degrees</span>
<span class="sd">        :param lat: latitude in degrees</span>
<span class="sd">        :param reverse: if True, do the reverse transform.</span>

<span class="sd">        Computation adapted from arpifs/transform/trareca.F90 and tracare.F90.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">:</span>
            <span class="n">KTYP</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">KTYP</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">PFACDI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">]</span>
        <span class="n">ZDBLC</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">PFACDI</span>
        <span class="n">ZC2P1</span> <span class="o">=</span> <span class="n">PFACDI</span> <span class="o">*</span> <span class="n">PFACDI</span> <span class="o">+</span> <span class="mf">1.</span>
        <span class="n">ZC2M1</span> <span class="o">=</span> <span class="n">PFACDI</span> <span class="o">*</span> <span class="n">PFACDI</span> <span class="o">-</span> <span class="mf">1.</span>
        <span class="n">ZCRAP</span> <span class="o">=</span> <span class="o">-</span><span class="n">ZC2M1</span> <span class="o">/</span> <span class="n">ZC2P1</span>
        <span class="n">ZEPS</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">epsilon</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;rotated&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">lon0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lon0</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lon0</span><span class="p">)</span>
            <span class="n">PSLAR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span>
            <span class="n">PSLOR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
            <span class="n">PCLOR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">KTYP</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Complete ARPEGE</span>
                <span class="p">(</span><span class="n">PCLAP</span><span class="p">,</span> <span class="n">PSLAP</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cos_sin&#39;</span><span class="p">)</span>
                <span class="p">(</span><span class="n">PCLOP</span><span class="p">,</span> <span class="n">PSLOP</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cos_sin&#39;</span><span class="p">)</span>
                <span class="n">ZCLAR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">PSLAR</span> <span class="o">*</span> <span class="n">PSLAR</span><span class="p">)</span>
                <span class="n">ZA</span> <span class="o">=</span> <span class="n">PSLAP</span> <span class="o">*</span> <span class="n">PSLAR</span> <span class="o">+</span> <span class="n">PCLAP</span> <span class="o">*</span> <span class="n">ZCLAR</span> <span class="o">*</span> \
                     <span class="p">(</span><span class="n">PCLOP</span> <span class="o">*</span> <span class="n">PCLOR</span> <span class="o">+</span> <span class="n">PSLOP</span> <span class="o">*</span> <span class="n">PSLOR</span><span class="p">)</span>
                <span class="n">PSLAC</span> <span class="o">=</span> <span class="p">(</span><span class="n">ZCRAP</span> <span class="o">+</span> <span class="n">ZA</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">ZA</span> <span class="o">*</span> <span class="n">ZCRAP</span><span class="p">)</span>
                <span class="n">ZB</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ZEPS</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">ZA</span> <span class="o">*</span> <span class="n">ZA</span><span class="p">))</span>
                <span class="n">PCLOC</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCLAP</span> <span class="o">*</span> <span class="n">PSLAR</span> <span class="o">-</span> <span class="n">PSLAP</span> <span class="o">*</span> <span class="n">ZCLAR</span> <span class="o">*</span>
                         <span class="p">(</span><span class="n">PCLOP</span> <span class="o">*</span> <span class="n">PCLOR</span> <span class="o">+</span> <span class="n">PSLOP</span> <span class="o">*</span> <span class="n">PSLOR</span><span class="p">))</span> <span class="o">*</span> <span class="n">ZB</span>
                <span class="n">PSLOC</span> <span class="o">=</span> <span class="n">ZCLAR</span> <span class="o">*</span> <span class="p">(</span><span class="n">PSLOP</span> <span class="o">*</span> <span class="n">PCLOR</span> <span class="o">-</span> <span class="n">PCLOP</span> <span class="o">*</span> <span class="n">PSLOR</span><span class="p">)</span> <span class="o">*</span> <span class="n">ZB</span>
                <span class="n">PSLAC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLAC</span><span class="p">))</span>
                <span class="n">PCLOC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PCLOC</span><span class="p">))</span>
                <span class="n">PSLOC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLOC</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">PSLOC</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">PSLOC</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">PCLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">PCLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">PSLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">PSLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
                            <span class="n">PSLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                            <span class="n">PCLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">PCLOC</span> <span class="o">*</span> <span class="n">PCLOC</span> <span class="o">+</span> <span class="n">PSLOC</span> <span class="o">*</span> <span class="n">PSLOC</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
                        <span class="n">PSLOC</span> <span class="o">=</span> <span class="mf">1.</span>
                        <span class="n">PCLOC</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Schmidt</span>
                <span class="n">PSLOC</span> <span class="o">=</span> <span class="n">PSLOR</span>
                <span class="n">PCLOC</span> <span class="o">=</span> <span class="n">PCLOR</span>
                <span class="n">PSLAC</span> <span class="o">=</span> <span class="p">(</span><span class="n">ZC2P1</span> <span class="o">*</span> <span class="n">PSLAR</span> <span class="o">-</span> <span class="n">ZC2M1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ZC2P1</span> <span class="o">-</span> <span class="n">ZC2M1</span> <span class="o">*</span> <span class="n">PSLAR</span><span class="p">)</span>
                <span class="n">PSLAC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLAC</span><span class="p">))</span>

            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">PSLAC</span><span class="p">)</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">PSLOC</span><span class="p">,</span> <span class="n">PCLOC</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">PSLAC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span>
            <span class="n">PCLOC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
            <span class="n">PSLOC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">KTYP</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Complete ARPEGE</span>
                <span class="p">(</span><span class="n">PCLAP</span><span class="p">,</span> <span class="n">PSLAP</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cos_sin&#39;</span><span class="p">)</span>
                <span class="p">(</span><span class="n">PCLOP</span><span class="p">,</span> <span class="n">PSLOP</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cos_sin&#39;</span><span class="p">)</span>
                <span class="n">ZCLAC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">PSLAC</span> <span class="o">*</span> <span class="n">PSLAC</span><span class="p">)</span>
                <span class="n">ZA</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">ZC2P1</span> <span class="o">+</span> <span class="n">ZC2M1</span> <span class="o">*</span> <span class="n">PSLAC</span><span class="p">)</span>
                <span class="n">ZB</span> <span class="o">=</span> <span class="n">ZC2P1</span> <span class="o">*</span> <span class="n">PSLAC</span> <span class="o">+</span> <span class="n">ZC2M1</span>
                <span class="n">ZC</span> <span class="o">=</span> <span class="n">ZDBLC</span> <span class="o">*</span> <span class="n">PCLAP</span> <span class="o">*</span> <span class="n">ZCLAC</span> <span class="o">*</span> <span class="n">PCLOC</span> <span class="o">+</span> <span class="n">ZB</span> <span class="o">*</span> <span class="n">PSLAP</span>
                <span class="n">PSLAR</span> <span class="o">=</span> <span class="n">ZC</span> <span class="o">*</span> <span class="n">ZA</span>
                <span class="n">ZD</span> <span class="o">=</span> <span class="n">ZA</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ZEPS</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">PSLAR</span> <span class="o">*</span> <span class="n">PSLAR</span><span class="p">))</span>
                <span class="n">ZE</span> <span class="o">=</span> <span class="n">ZB</span> <span class="o">*</span> <span class="n">PCLAP</span> <span class="o">*</span> <span class="n">PCLOP</span> <span class="o">-</span> <span class="n">ZDBLC</span> <span class="o">*</span> <span class="n">ZCLAC</span> <span class="o">*</span> \
                     <span class="p">(</span><span class="n">PSLAP</span> <span class="o">*</span> <span class="n">PCLOC</span> <span class="o">*</span> <span class="n">PCLOP</span> <span class="o">-</span> <span class="n">PSLOP</span> <span class="o">*</span> <span class="n">PSLOC</span><span class="p">)</span>
                <span class="n">ZF</span> <span class="o">=</span> <span class="n">ZB</span> <span class="o">*</span> <span class="n">PCLAP</span> <span class="o">*</span> <span class="n">PSLOP</span> <span class="o">-</span> <span class="n">ZDBLC</span> <span class="o">*</span> <span class="n">ZCLAC</span> <span class="o">*</span> \
                     <span class="p">(</span><span class="n">PSLAP</span> <span class="o">*</span> <span class="n">PCLOC</span> <span class="o">*</span> <span class="n">PSLOP</span> <span class="o">+</span> <span class="n">PCLOP</span> <span class="o">*</span> <span class="n">PSLOC</span><span class="p">)</span>
                <span class="n">PCLOR</span> <span class="o">=</span> <span class="n">ZE</span> <span class="o">*</span> <span class="n">ZD</span>
                <span class="n">PSLOR</span> <span class="o">=</span> <span class="n">ZF</span> <span class="o">*</span> <span class="n">ZD</span>
                <span class="n">PSLAR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLAR</span><span class="p">))</span>
                <span class="n">PCLOR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PCLOR</span><span class="p">))</span>
                <span class="n">PSLOR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLOR</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Schmidt</span>
                <span class="n">PSLOR</span> <span class="o">=</span> <span class="n">PSLOC</span>
                <span class="n">PCLOR</span> <span class="o">=</span> <span class="n">PCLOC</span>
                <span class="n">PSLAR</span> <span class="o">=</span> <span class="p">(</span><span class="n">ZC2P1</span> <span class="o">*</span> <span class="n">PSLAC</span> <span class="o">+</span> <span class="n">ZC2M1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ZC2P1</span> <span class="o">+</span> <span class="n">ZC2M1</span> <span class="o">*</span> <span class="n">PSLAC</span><span class="p">)</span>
                <span class="n">PSLAR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLAR</span><span class="p">))</span>

            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">PSLOR</span><span class="p">,</span> <span class="n">PCLOR</span><span class="p">)</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">PSLAR</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>

<div class="viewcode-block" id="GaussGeometry.map_factor"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.map_factor">[docs]</a>    <span class="k">def</span> <span class="nf">map_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the map factor at the given longitude/latitude(s)</span>

<span class="sd">        :param lon: longitude in degrees</span>
<span class="sd">        :param lat: latitude in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">plab</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_stretch</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="n">zlat1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">plab</span><span class="p">)</span>
        <span class="c1"># From rotated/streched sphere to rotated</span>
        <span class="n">zinterm</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">pc</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlat1</span><span class="p">))</span>
        <span class="n">zlat2</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">zinterm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">zinterm</span><span class="p">))</span>
        <span class="n">zm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat1</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">zm</span></div>

<div class="viewcode-block" id="GaussGeometry.map_factor_field"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.map_factor_field">[docs]</a>    <span class="k">def</span> <span class="nf">map_factor_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new field whose data is the map factor over the field.</span>

<span class="sd">        :param position: grid position with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs_vcoord</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;typeoffirstfixedsurface&#39;</span><span class="p">:</span> <span class="mi">255</span><span class="p">,</span>
                         <span class="s1">&#39;position_on_grid&#39;</span><span class="p">:</span> <span class="s1">&#39;__unknown__&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;levels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
        <span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">VGeometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_vcoord</span><span class="p">)</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">=</span><span class="n">vcoordinate</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;H2D&#39;</span><span class="p">,</span>
                      <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span>
                      <span class="n">fid</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span><span class="s1">&#39;Map Factor&#39;</span><span class="p">},</span>
                      <span class="n">units</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_factor</span><span class="p">(</span><span class="n">stretch_array</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="n">stretch_array</span><span class="p">(</span><span class="n">lats</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span></div>

<div class="viewcode-block" id="GaussGeometry.reproject_wind_on_lonlat"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.reproject_wind_on_lonlat">[docs]</a>    <span class="k">def</span> <span class="nf">reproject_wind_on_lonlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span>
                                 <span class="n">map_factor_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reprojects a wind vector (u, v) on rotated/stretched sphere onto real</span>
<span class="sd">        sphere, i.e. with components on true zonal/meridian axes.</span>

<span class="sd">        :param u: the u == zonal-on-the-grid component of wind</span>
<span class="sd">        :param v: the v == meridian-on-the-grid component of wind</span>
<span class="sd">        :param lon: longitudes of points in degrees</span>
<span class="sd">        :param lat: latitudes of points in degrees</span>
<span class="sd">        :param map_factor_correction: applies a correction of magnitude due</span>
<span class="sd">                                      to map factor.</span>
<span class="sd">        :param reverse: if True, apply the reverse reprojection.</span>

<span class="sd">        lon/lat are coordinates on real sphere.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;rotated&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">plac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plac</span> <span class="o">=</span> <span class="mf">90.</span>
        <span class="p">(</span><span class="n">plob</span><span class="p">,</span> <span class="n">plab</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_stretch</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="c1"># the below formulas seem to be working with</span>
        <span class="c1"># lon_on_rotated_sphere begining below pole_of_rotation,</span>
        <span class="c1"># hence a 180° rotation.</span>
        <span class="n">plob</span> <span class="o">+=</span> <span class="mf">180.</span>
        <span class="n">pust</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">pvst</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># Adapted from J.M.Piriou&#39;s pastrv.F90</span>
        <span class="n">zlon1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">plob</span><span class="p">)</span>
        <span class="n">zlat1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">plab</span><span class="p">)</span>
        <span class="n">zlatp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">plac</span><span class="p">)</span>

        <span class="c1"># From rotated/streched sphere to rotated</span>
        <span class="n">zinterm</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">pc</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlat1</span><span class="p">))</span>
        <span class="n">zlat2</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">zinterm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">zinterm</span><span class="p">))</span>
        <span class="n">zlon2</span> <span class="o">=</span> <span class="n">zlon1</span>

        <span class="c1"># Map factor</span>
        <span class="k">if</span> <span class="n">map_factor_correction</span><span class="p">:</span>
            <span class="n">zm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat1</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span>
            <span class="c1"># zm = self.map_factor(lon, lat) # but redundant computations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="n">epylog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;check carefully *map_factor_correction* w.r.t. dilatation_coef&#39;</span><span class="p">)</span>
            <span class="n">zm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">zlat1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># From rotated sphere to real sphere</span>
        <span class="c1"># Compute latitude on real sphere</span>
        <span class="n">zsla3</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlon2</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlatp</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlatp</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">zsla3</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">zsla3</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">epylog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;reproject_wind_on_lonlat: zsla3=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">zsla3</span><span class="p">))</span>
            <span class="n">zsla3</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">zsla3</span><span class="p">))</span>
        <span class="n">zlat3</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">zsla3</span><span class="p">)</span>

        <span class="c1"># Real North components</span>
        <span class="n">zca</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlatp</span><span class="p">)</span> <span class="o">+</span>
               <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlatp</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlon2</span><span class="p">))</span> <span class="o">/</span> \
               <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat3</span><span class="p">)</span>
        <span class="n">zsa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlatp</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlon2</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat3</span><span class="p">)</span>

        <span class="c1"># Wind transformation</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">zm</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">zm</span>
            <span class="n">zsa</span> <span class="o">=</span> <span class="o">-</span><span class="n">zsa</span>
        <span class="n">pusr</span> <span class="o">=</span> <span class="n">zm</span> <span class="o">*</span> <span class="p">(</span><span class="n">zca</span> <span class="o">*</span> <span class="n">pust</span> <span class="o">-</span> <span class="n">zsa</span> <span class="o">*</span> <span class="n">pvst</span><span class="p">)</span>
        <span class="n">pvsr</span> <span class="o">=</span> <span class="n">zm</span> <span class="o">*</span> <span class="p">(</span><span class="n">zsa</span> <span class="o">*</span> <span class="n">pust</span> <span class="o">+</span> <span class="n">zca</span> <span class="o">*</span> <span class="n">pvst</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">pusr</span><span class="p">,</span> <span class="n">pvsr</span><span class="p">)</span></div>

<div class="viewcode-block" id="GaussGeometry.nearest_points"><a class="viewcode-back" href="../../../library/GaussGeometry.html#epygram.geometries.GaussGeometry.GaussGeometry.nearest_points">[docs]</a>    <span class="k">def</span> <span class="nf">nearest_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span>
                       <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">external_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">squeeze</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the (i, j) position of the points needed to perform</span>
<span class="sd">        an interpolation.</span>

<span class="sd">        :param lon: longitude of point in degrees.</span>
<span class="sd">        :param lat: latitude of point in degrees.</span>
<span class="sd">        :param request: criteria for selecting the points, among:</span>
<span class="sd">               * {&#39;n&#39;:&#39;1&#39;} - the nearest point</span>
<span class="sd">               * {&#39;n&#39;:&#39;2*2&#39;} - the 2*2 square points around the position</span>
<span class="sd">               * {&#39;n&#39;:&#39;4*4&#39;} - the 4*4 square points around the position</span>
<span class="sd">               * {&#39;n&#39;:&#39;N*N&#39;} - the N*N square points around the position: N must be even</span>
<span class="sd">               * {&#39;radius&#39;:xxxx, &#39;shape&#39;:&#39;square&#39;} - the points which are xxxx metres</span>
<span class="sd">                 around the position in X or Y direction</span>
<span class="sd">               * {&#39;radius&#39;:xxxx, &#39;shape&#39;:&#39;circle&#39;} - the points within xxxx metres</span>
<span class="sd">                 around the position. (default shape == circle)</span>
<span class="sd">        :param position: position in the model cell of the lat lon position.</span>
<span class="sd">               Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        :param external_distance: can be a dict containing the target point value</span>
<span class="sd">               and an external field on the same grid as self, to which the distance</span>
<span class="sd">               is computed within the 4 horizontally nearest points; e.g.</span>
<span class="sd">               {&#39;target_value&#39;:4810, &#39;external_field&#39;:a_3DField_with_same_geometry}.</span>
<span class="sd">               If so, the nearest point is selected with</span>
<span class="sd">               distance = |target_value - external_field.data|</span>
<span class="sd">        :param squeeze: True to suppress useless dimensions</span>

<span class="sd">        :rtype: general output form is [list, list, ..., list]</span>
<span class="sd">                with as many list items as the length of lon/lat.</span>
<span class="sd">                Each list item is of the form [tuple, tuple, ..., tuple]</span>
<span class="sd">                with as many tuples as the request implies. A tuple</span>
<span class="sd">                represents one of the nearest points associated with one</span>
<span class="sd">                value taken from lon/lat. Each tuple as the form</span>
<span class="sd">                (i, j).</span>

<span class="sd">                Dimensions with a length of one are removed except if</span>
<span class="sd">                squeeze is False. If squeeze is True and if request</span>
<span class="sd">                implies only one nearest point, the list item of the general</span>
<span class="sd">                output form is replaced by the tuple item; if length of</span>
<span class="sd">                lon/lat is one, the output is directly the list item of</span>
<span class="sd">                the general output form. Hence, if length of lon/lat is</span>
<span class="sd">                one and the request implies only one point, the output is</span>
<span class="sd">                a tuple.</span>

<span class="sd">                In case of a simple square request, output is actually</span>
<span class="sd">                an array. Otherwise, the output is as described (it cannot</span>
<span class="sd">                be an array because the number of nearest points can vary</span>
<span class="sd">                with the entry point).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;horizontal staggered grids for &quot;</span> <span class="o">+</span>
                                      <span class="s2">&quot;reduced gauss grid are not implemented.&quot;</span><span class="p">)</span>

        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># ## internal functions</span>
        <span class="k">def</span> <span class="nf">nearest_lats</span><span class="p">(</span><span class="n">latrs</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Internal method used to find the nearest latitude circles.</span>

<span class="sd">            *latrs* is the rotated and streched latitude.</span>
<span class="sd">            *num* is:</span>
<span class="sd">            - 2 to find the two surrounding latitude cicles,</span>
<span class="sd">            - 3 to find the nearest latitude circles plus the one above</span>
<span class="sd">                and the one under.</span>
<span class="sd">            - 4 to find the two surrounding latitude circles plus the</span>
<span class="sd">                preceding one and the following one.</span>
<span class="sd">            - and so on...</span>

<span class="sd">            returns an array of shape (len(latrs), num)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">latitudes</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">&lt;=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">latitudes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;latitudes must be in descending order&#39;</span><span class="p">)</span>

            <span class="n">latrs</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">latrs</span><span class="p">)</span>
            <span class="n">nearest</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">),</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">distmin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">),</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Slicing is needed to prevent memory error</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># on a particular example, increasing this value implies a longuer execution time</span>
            <span class="k">for</span> <span class="n">imin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="n">imax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">imin</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">))</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">latrs</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">latitudes</span><span class="p">)[</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">nearest</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dist</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">distmin</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">nearest</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">]]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">),</span> <span class="n">num</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">distmin</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># odd</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">k</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># even</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">k</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">nearest</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">def</span> <span class="nf">nearest_lons</span><span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">latnum</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Internal method used to find the nearest points on a latitude</span>
<span class="sd">            circle.</span>

<span class="sd">            Args:\n</span>
<span class="sd">            - *lonrs* is the rotated and streched longitude.</span>
<span class="sd">            - *num* is:</span>
<span class="sd">              - 1 to find the nearest point,</span>
<span class="sd">              - 2 to find the two surrounding points,</span>
<span class="sd">              - 4 to find the two surrounding points plus the preceding one and</span>
<span class="sd">                  the following one.</span>
<span class="sd">              - and so on</span>
<span class="sd">            - *latnum*: if -1 (resp. -2), we search for the opposite longitude</span>
<span class="sd">              on the first (resp. second) latitude circle.</span>
<span class="sd">              The same is true for the other pole.</span>

<span class="sd">            latnum must be of shape (len(lonrs), x) where x is the number of latitude</span>
<span class="sd">            to search for each longitude</span>

<span class="sd">            result shape is (len(lonrs), x, num, 2)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">lonrs</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lonrs</span><span class="p">)</span>
            <span class="n">latnum</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">latnum</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lonrs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lonrs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">lonrs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lonrs</span><span class="p">)</span>
            <span class="n">lonnummax</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">lonrs2d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">lonrs</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Near the pole, have to look-up on the first latitudes</span>
            <span class="c1"># circles, symmetrically with regards to the pole</span>
            <span class="n">mask1</span> <span class="o">=</span> <span class="n">latnum</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">j</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">latnum</span><span class="p">[</span><span class="n">mask1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])[</span><span class="n">j</span><span class="p">[</span><span class="n">mask1</span><span class="p">]]</span>
            <span class="n">i</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">lonrs2d</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> \
                       <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">mask2</span> <span class="o">=</span> <span class="n">latnum</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">latitudes</span><span class="p">)</span>
            <span class="n">j</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">latitudes</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">latnum</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">latitudes</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># TOBECHECKED: next circle past the pole</span>
            <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])[</span><span class="n">j</span><span class="p">[</span><span class="n">mask2</span><span class="p">]]</span>
            <span class="n">i</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">lonrs2d</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> \
                            <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">))</span>
            <span class="n">j</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">latnum</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])[</span><span class="n">latnum</span><span class="p">[</span><span class="n">mask</span><span class="p">]]</span>
            <span class="n">i</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">lonrs2d</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">lonnummax</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">elif</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">lonnummax</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">lonnummax</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">elif</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># odd</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;but is it necessary ?&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># even</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ii</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="n">lonnummax</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">%</span> <span class="n">lonnummax</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ii</span> <span class="o">+</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="n">lonnummax</span>  <span class="c1"># reverse order? why?</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">def</span> <span class="nf">nearest</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Internal method used to find the nearest point.</span>
<span class="sd">            lon/lat are the true coordinate, lonrs/latrs are rotated and</span>
<span class="sd">            streched coordinates.</span>

<span class="sd">            Returns an array of points</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lonrs</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">latrs</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lonrs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">)</span>

            <span class="n">all_nearest_lats</span> <span class="o">=</span> <span class="n">nearest_lats</span><span class="p">(</span><span class="n">latrs</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">all_nearest_lons</span> <span class="o">=</span> <span class="n">nearest_lons</span><span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">all_nearest_lats</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">lon2d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">lon</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">lat2d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">lat</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">all_nearest_lons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                              <span class="n">all_nearest_lons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span>
            <span class="n">all_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">((</span><span class="n">lon2d</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">lat2d</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">ll</span><span class="p">)</span>
            <span class="n">all_dist</span> <span class="o">=</span> <span class="n">all_dist</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lonrs</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">all_nearest_lons</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">all_dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">all_dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">def</span> <span class="nf">nearests</span><span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Internal methods used to find the n*n points surrunding the</span>
<span class="sd">            point lonrs/latrs, lonrs/latrs are rotated and stretched</span>
<span class="sd">            coordinates.</span>

<span class="sd">            lonrs and latrs can be arrays</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">lonrs</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lonrs</span><span class="p">)</span>
            <span class="n">latrs</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">latrs</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">lonrs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">latrs</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lonrs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;only scalar or 1d arrays with same length&quot;</span>

            <span class="n">all_nearest_lats</span> <span class="o">=</span> <span class="n">nearest_lats</span><span class="p">(</span><span class="n">latrs</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">all_nearest_lons</span> <span class="o">=</span> <span class="n">nearest_lons</span><span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">all_nearest_lats</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">all_nearest_lons</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lonrs</span><span class="p">),</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># ## actual algorithm</span>
        <span class="c1"># initializations</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">latitudes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">])]</span>
        <span class="c1"># compute rotated/stretched lon/lat</span>
        <span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_stretch</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="c1"># 1.A: nearest point is needed only</span>
        <span class="n">nsquare_match</span> <span class="o">=</span> <span class="n">_re_nearest_sq</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nsquare_match</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">),</span> \
                <span class="s2">&quot;anisotropic request {&#39;n&#39;:&#39;N*M&#39;} is not supported.&quot;</span>
        <span class="k">if</span> <span class="n">external_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">request</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="s1">&#39;1&#39;</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">_increments</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;academic&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">i_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;academic&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">j_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">i_incr</span><span class="p">,</span> <span class="n">j_incr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">request</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="s1">&#39;1&#39;</span><span class="p">}</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">external_distance</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">nearest</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span><span class="p">)</span>
        <span class="c1"># 2.: several points are needed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 2.1: how many ?</span>
            <span class="k">if</span> <span class="n">external_distance</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;request:{&#39;radius&#39;:..., &#39;shape&#39;:&#39;radius&#39;} with several points.&quot;</span><span class="p">)</span>
                <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">resolution</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nsquare_match</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;unrecognized **request**: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">request</span><span class="p">))</span>
            <span class="c1"># 2.2: get points</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">nearests</span><span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

            <span class="c1"># 2.3: only select the nearest with regards to external_distance</span>
            <span class="k">if</span> <span class="n">external_distance</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># We transform into list to be able to modify the length</span>
                <span class="k">for</span> <span class="n">ipt</span><span class="p">,</span> <span class="n">points</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                    <span class="n">mindistance</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">external_distance</span><span class="p">[</span><span class="s1">&#39;external_field&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getvalue_ij</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">one</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="n">external_distance</span><span class="p">[</span><span class="s1">&#39;target_value&#39;</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">mindistance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">mindistance</span><span class="p">:</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
                            <span class="n">mindistance</span> <span class="o">=</span> <span class="n">dist</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># all item must now have the same length</span>

        <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># We transform into list to be able to modify the length</span>
            <span class="k">for</span> <span class="n">ipt</span><span class="p">,</span> <span class="n">points</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;circle&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;circle&#39;</span><span class="p">:</span>
                    <span class="c1">#for i,j in points:</span>
                    <span class="c1">#    print(i,j,self.distance((lon[ipt], lat[ipt]), self.ij2ll(i, j)))</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">points</span>
                                   <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">((</span><span class="n">lon</span><span class="p">[</span><span class="n">ipt</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">ipt</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;square&#39;</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">points</span>
                                   <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="n">lon</span><span class="p">[</span><span class="n">ipt</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">ipt</span><span class="p">]))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)))</span> <span class="o">&lt;=</span> <span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">])]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;no points found: radius may be too small.&quot;</span>
            <span class="k">if</span> <span class="n">squeeze</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span> <span class="nf">_what_grid_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">spectral_geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the grid &amp; dimensions of the field.</span>

<span class="sd">        :param out: the output open file-like object</span>
<span class="sd">        :param spectral_geometry: an optional dict containing the spectral</span>
<span class="sd">          truncature {&#39;max&#39;:}.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="n">gridmap</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;reduced_gauss&#39;</span><span class="p">:</span><span class="s1">&#39;Reduced Gauss&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">:</span><span class="s1">&#39;Rotated Reduced Gauss&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;regular_gauss&#39;</span><span class="p">:</span><span class="s1">&#39;Regular Gauss&#39;</span><span class="p">}</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Grid&quot;</span><span class="p">,</span> <span class="n">gridmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">:</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Pole Longitude&quot;</span><span class="p">,</span>
                            <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Pole Latitude&quot;</span><span class="p">,</span>
                            <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Dilatation coefficient&quot;</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Number of latitudes&quot;</span><span class="p">,</span>
                        <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Maximum number of longitudes on a parallel&quot;</span><span class="p">,</span>
                        <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;max_lon_number&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">spectral_geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Truncation&quot;</span><span class="p">,</span>
                            <span class="n">spectral_geometry</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">])</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">epygram 1.5.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../epygram.html" >epygram</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../geometries.html" >epygram.geometries</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">epygram.geometries.GaussGeometry</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014 --- 2024, A.Mary, S.Riette.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>