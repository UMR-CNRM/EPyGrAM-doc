
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>epygram.geometries.D3Geometry &#8212; epygram 1.4.18 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinxdoc.css" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">epygram 1.4.18 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../epygram.html" >epygram</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../geometries.html" accesskey="U">epygram.geometries</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">epygram.geometries.D3Geometry</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for epygram.geometries.D3Geometry</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Copyright (c) Météo France (2014-)</span>
<span class="c1"># This software is governed by the CeCILL-C license under French law.</span>
<span class="c1"># http://www.cecill.info</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Contains the classes for 3D geometries of fields.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">import</span> <span class="nn">footprints</span>
<span class="kn">from</span> <span class="nn">footprints</span> <span class="kn">import</span> <span class="n">FootprintBase</span><span class="p">,</span> <span class="n">FPDict</span><span class="p">,</span> <span class="n">FPList</span><span class="p">,</span> <span class="n">proxy</span> <span class="k">as</span> <span class="n">fpx</span>
<span class="kn">from</span> <span class="nn">bronx.graphics.axes</span> <span class="kn">import</span> <span class="n">set_figax</span>
<span class="kn">from</span> <span class="nn">bronx.syntax.arrays</span> <span class="kn">import</span> <span class="n">stretch_array</span>
<span class="kn">from</span> <span class="nn">bronx.syntax.decorators</span> <span class="kn">import</span> <span class="n">nicedeco</span>

<span class="kn">from</span> <span class="nn">epygram</span> <span class="kn">import</span> <span class="n">epygramError</span><span class="p">,</span> <span class="n">config</span>
<span class="kn">from</span> <span class="nn">epygram.config</span> <span class="kn">import</span> <span class="n">rounding_decimal</span> <span class="k">as</span> <span class="n">_rd</span>
<span class="kn">from</span> <span class="nn">epygram.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">RecursiveObject</span><span class="p">,</span> <span class="n">degrees_nearest_mod</span><span class="p">,</span> <span class="n">Angle</span><span class="p">,</span>
                          <span class="n">positive_longitudes</span><span class="p">,</span> <span class="n">longitudes_between_minus180_180</span><span class="p">,</span>
                          <span class="n">separation_line</span><span class="p">,</span> <span class="n">write_formatted</span><span class="p">,</span>
                          <span class="n">nearlyEqual</span><span class="p">,</span>
                          <span class="n">as_numpy_array</span><span class="p">,</span> <span class="n">moveaxis</span><span class="p">,</span>
                          <span class="n">is_scalar</span><span class="p">,</span> <span class="n">Comparator</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.VGeometry</span> <span class="kn">import</span> <span class="n">VGeometry</span>

<span class="n">epylog</span> <span class="o">=</span> <span class="n">footprints</span><span class="o">.</span><span class="n">loggers</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">_re_nearest_sq</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(?P&lt;n&gt;\d+)\*(?P&lt;m&gt;\d+)&#39;</span><span class="p">)</span>


<span class="nd">@nicedeco</span>
<span class="k">def</span> <span class="nf">_need_pyproj_geod</span><span class="p">(</span><span class="n">mtd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator for Geometry object: if the method needs a pyproj.Geod</span>
<span class="sd">    object to be set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">with_geod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_pyproj_geod&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_geoid</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mtd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">with_geod</span>


<div class="viewcode-block" id="D3Geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry">[docs]</a><span class="k">class</span> <span class="nc">D3Geometry</span><span class="p">(</span><span class="n">RecursiveObject</span><span class="p">,</span> <span class="n">FootprintBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles the geometry for a 3-Dimensions Field.</span>
<span class="sd">    Abstract mother class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_abstract</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_collector</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,)</span>
    <span class="n">_footprint</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">attr</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">structure</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">info</span><span class="o">=</span><span class="s2">&quot;Type of geometry.&quot;</span><span class="p">,</span>
                <span class="n">values</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;3D&#39;</span><span class="p">])),</span>
            <span class="n">name</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">info</span><span class="o">=</span><span class="s2">&quot;Name of geometrical type of representation of points on </span><span class="se">\</span>
<span class="s2">                      the Globe.&quot;</span><span class="p">,</span>
                <span class="n">values</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;lambert&#39;</span><span class="p">,</span> <span class="s1">&#39;mercator&#39;</span><span class="p">,</span> <span class="s1">&#39;polar_stereographic&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;regular_lonlat&#39;</span><span class="p">,</span> <span class="s1">&#39;rotated_lonlat&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">,</span> <span class="s1">&#39;reduced_gauss&#39;</span><span class="p">,</span> <span class="s1">&#39;regular_gauss&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;unstructured&#39;</span><span class="p">])),</span>
            <span class="n">grid</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">FPDict</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="s2">&quot;Handles description of the horizontal grid.&quot;</span><span class="p">),</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">FPDict</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="s2">&quot;Handles grid dimensions.&quot;</span><span class="p">),</span>
            <span class="n">vcoordinate</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">access</span><span class="o">=</span><span class="s1">&#39;rwx&#39;</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">VGeometry</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="s2">&quot;Handles vertical geometry parameters.&quot;</span><span class="p">),</span>
            <span class="n">position_on_horizontal_grid</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">access</span><span class="o">=</span><span class="s1">&#39;rwx&#39;</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="s2">&quot;Position of points w/r to the horizontal.&quot;</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="s1">&#39;__unknown__&#39;</span><span class="p">,</span>
                <span class="n">values</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;upper-right&#39;</span><span class="p">,</span> <span class="s1">&#39;upper-left&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;lower-left&#39;</span><span class="p">,</span> <span class="s1">&#39;lower-right&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;center-left&#39;</span><span class="p">,</span> <span class="s1">&#39;center-right&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;lower-center&#39;</span><span class="p">,</span> <span class="s1">&#39;upper-center&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;__unknown__&#39;</span><span class="p">])),</span>
            <span class="n">geoid</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">FPDict</span><span class="p">,</span>
                <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="n">FPDict</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">default_geoid</span><span class="p">),</span>
                <span class="n">info</span><span class="o">=</span><span class="s2">&quot;To specify geoid shape.&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># ghost attributes are ignored when comparing 2 objects between them</span>
    <span class="n">_ghost_attributes</span> <span class="o">=</span> <span class="n">RecursiveObject</span><span class="o">.</span><span class="n">_ghost_attributes</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;_puredict&#39;</span><span class="p">,</span> <span class="s1">&#39;_observer&#39;</span><span class="p">]</span>  <span class="c1"># footprints special attributes</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">D3Geometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Checks !</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_consistency_check</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_consistency_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># implemented in child classes</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rectangular_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Is the grid rectangular ? &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">D3RectangularGridGeometry</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">projected_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Is the geometry a projection ? &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;projection&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">datashape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the data shape requested by this geometry.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;3D&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;V2D&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;H2D&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;H1D&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;V1D&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">}</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">==</span> <span class="s2">&quot;Point&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s1">&#39;This structure is unknown&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="D3Geometry.get_levels"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.get_levels">[docs]</a>    <span class="k">def</span> <span class="nf">get_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nb_validities</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an array containing the level for each data point.</span>

<span class="sd">        :param d4: - if True,  returned values are shaped in a 4 dimensions array</span>
<span class="sd">                   - if False, shape of returned values is determined with respect to geometry</span>
<span class="sd">                     d4=True requires nb_validities &gt; 0</span>
<span class="sd">        :param nb_validities: the number of validities represented in data values</span>
<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, extracts</span>
<span class="sd">          the levels resp. from the C or C+I zone off the C+I(+E) zone.</span>

<span class="sd">        Levels are internally stored with the vertical dimension first whereas this</span>
<span class="sd">        method puts the time in first dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">d4</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nb_validities</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nb_validities must be &gt;=1 when d4==True&quot;</span><span class="p">)</span>

        <span class="n">levels</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>

        <span class="c1"># We add the horizontal axis</span>
        <span class="n">h_shape2D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">d4</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">dimT</span><span class="o">=</span><span class="n">nb_validities</span><span class="p">,</span>
                                       <span class="n">force_dimZ</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                       <span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># level values constant over the horizontal domain and time</span>
            <span class="c1"># We add the horizontal dimension</span>
            <span class="n">original_has_time</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">d4</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">h_shape2D</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">h_shape2D</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">d4</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">h_shape2D</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">h_shape2D</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># level values with horizontal variations</span>
            <span class="n">h_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">force_dimZ</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># workaround for inconsistency between rectangular and gauss, self.get_datashape(force_dimZ=1)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_shape</span><span class="p">):</span>
                <span class="n">original_has_time</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_shape</span><span class="p">):</span>
                <span class="n">original_has_time</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;Wrong number of dimensions&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_shape</span><span class="p">):]</span> <span class="o">!=</span> <span class="n">h_shape</span><span class="p">:</span>  <span class="c1"># OK for h_shape=tuple()</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;Shape of self.vcoordinate.levels does not agree with horizontal dimensions&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subzone</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_subzone</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">subzone</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d4</span> <span class="ow">and</span> <span class="p">((</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">])):</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_shape</span><span class="p">)]</span>  <span class="c1"># shape without the horizontal dimensions, OK for h_shape=tuple()</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">h_shape2D</span><span class="p">))</span>  <span class="c1"># shape with the new horizontal dimensions</span>
                <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># We suppress the vertical dimension if we do not need it</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">d4</span> <span class="ow">and</span> <span class="n">nb_validities</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># We add the time axis</span>
        <span class="k">if</span> <span class="n">original_has_time</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nb_validities</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;Shape of self.vcoordinate.levels does not agree with nb_validities&quot;</span><span class="p">)</span>
            <span class="n">shape_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">2</span><span class="p">:])))</span>
        <span class="k">elif</span> <span class="n">d4</span> <span class="ow">or</span> <span class="n">nb_validities</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">levels</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">nb_validities</span><span class="p">])</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">nb_validities</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">shape_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">levels</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">shape_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>  <span class="c1"># last axis in first</span>

        <span class="k">return</span> <span class="n">levels</span></div>

<div class="viewcode-block" id="D3Geometry.vcoord_as_field"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.vcoord_as_field">[docs]</a>    <span class="k">def</span> <span class="nf">vcoord_as_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">surface_type</span><span class="p">,</span> <span class="n">validity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a field filled with the level values associated to a fake geometry</span>
<span class="sd">        :param validity: validities to associate with the returned field</span>
<span class="sd">                         if None, we try without setting validity</span>
<span class="sd">        :param surface_type: typeOfFirstFixedSurface to associate to the fake geometry</span>
<span class="sd">        :param levels: list of values to use as the levels of the fake geometry</span>
<span class="sd">                       if None, levels will be replaced by a range</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">vgeom_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">_attributes</span><span class="p">)</span>
        <span class="n">vgeom_kwargs</span><span class="p">[</span><span class="s1">&#39;typeOfFirstFixedSurface&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">surface_type</span>
        <span class="n">vgeom_kwargs</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">))</span> <span class="k">if</span> <span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">levels</span>
        <span class="n">geometry</span><span class="o">.</span><span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">vgeom_kwargs</span><span class="p">)</span>
        <span class="n">field_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fid</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">temp</span><span class="o">=</span><span class="s1">&#39;temp&#39;</span><span class="p">),</span>
                            <span class="n">structure</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span>
                            <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">validity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">field_kwargs</span><span class="p">[</span><span class="s1">&#39;validity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">validity</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="o">**</span><span class="n">field_kwargs</span><span class="p">)</span>
        <span class="n">field</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_levels</span><span class="p">(</span><span class="n">d4</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nb_validities</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">validity</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">validity</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">field</span></div>

    <span class="k">def</span> <span class="nf">_getoffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the offset to use for this **position**.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">position</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_on_horizontal_grid</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="s1">&#39;__unknown__&#39;</span> <span class="ow">or</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;position_on_horizontal_grid must be&quot;</span> <span class="o">+</span>
                               <span class="s2">&quot; defined.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;upper-right&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;upper-left&#39;</span>  <span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;lower-left&#39;</span>  <span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;lower-right&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="mf">.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;center-left&#39;</span> <span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span>
                <span class="s1">&#39;center-right&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span>
                <span class="s1">&#39;lower-center&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;upper-center&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">.5</span><span class="p">),</span>
                <span class="s1">&#39;center&#39;</span>      <span class="p">:</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)}[</span><span class="n">pos</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_set_geoid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pyproj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Geod</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">)</span>

<div class="viewcode-block" id="D3Geometry.distance"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.distance">[docs]</a>    <span class="nd">@_need_pyproj_geod</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the distance between two points along a Great Circle.</span>

<span class="sd">        :param end1: first point, must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: second point, must be a tuple (lon, lat) in degrees.</span>

<span class="sd">        If one of (end1, end2) is a tuple of arrays (like (&lt;array of lon&gt;, &lt;array of lat&gt;))</span>
<span class="sd">        the other one must be a scalar tuple or a tuple of arrays with same dimensions.</span>

<span class="sd">        Warning: requires the :mod:`pyproj` module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">is_scalar</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">[</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
        <span class="n">end1_0</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">end1_1</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">end2_0</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">end2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">end2_1</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">end2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_1</span><span class="p">),</span> <span class="s1">&#39;pb with dims&#39;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;only scalars or 1D arrays&#39;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">end1_0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">end1_0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">end1_1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">end1_1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">end2_0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">end2_0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">end2_0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">end2_1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">end2_1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">end1_0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s1">&#39;at least one point must be fixed or both arrays must have the same length&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="kc">True</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">end1_0</span><span class="p">,</span> <span class="n">end1_1</span><span class="p">,</span> <span class="n">end2_0</span><span class="p">,</span> <span class="n">end2_1</span><span class="p">]]:</span>
            <span class="c1"># inv method does not like masked arrays</span>
            <span class="c1"># and can raise a ValueError: undefined inverse geodesic (may be an antipodal point)</span>
            <span class="c1"># on masked points</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">end1_0</span> <span class="o">+</span> <span class="n">end1_1</span> <span class="o">+</span> <span class="n">end2_0</span> <span class="o">+</span> <span class="n">end2_1</span><span class="p">))</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">end1_0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">distance</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">end1_0</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">end1_1</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">end2_0</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">end2_1</span><span class="p">[</span><span class="n">mask</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">end1_0</span><span class="p">,</span> <span class="n">end1_1</span><span class="p">,</span> <span class="n">end2_0</span><span class="p">,</span> <span class="n">end2_1</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">scalar</span> <span class="k">else</span> <span class="n">distance</span></div>

<div class="viewcode-block" id="D3Geometry.linspace"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.linspace">[docs]</a>    <span class="nd">@_need_pyproj_geod</span>
    <span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns evenly spaced points over the specified interval.</span>
<span class="sd">        Points are lined up along a Great Circle.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param num: the number of points, including point1 and point2.</span>

<span class="sd">        Warning: requires the :mod:`pyproj` module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;num&#39; must be at least 2.&quot;</span><span class="p">)</span>
        <span class="n">transect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">npts</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                          <span class="n">end2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                          <span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">transect</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">end1</span><span class="p">)</span>
        <span class="n">transect</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">transect</span></div>

<div class="viewcode-block" id="D3Geometry.azimuth"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.azimuth">[docs]</a>    <span class="nd">@_need_pyproj_geod</span>
    <span class="k">def</span> <span class="nf">azimuth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initial bearing from *end1* to *end2* points following a Great Circle.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>

<span class="sd">        Warning: requires the :mod:`pyproj` module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="D3Geometry.make_point_geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.make_point_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_point_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a PointGeometry at coordinates *(lon,lat)* in degrees.&quot;&quot;&quot;</span>
        <span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">,</span>
                                   <span class="n">typeoffirstfixedsurface</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
                                   <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;Point&#39;</span><span class="p">,</span>
                            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;unstructured&#39;</span><span class="p">,</span>
                            <span class="n">vcoordinate</span><span class="o">=</span><span class="n">vcoordinate</span><span class="p">,</span>
                            <span class="n">dimensions</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span>
                            <span class="n">grid</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;longitudes&#39;</span><span class="p">:[</span><span class="n">lon</span><span class="p">],</span>
                                  <span class="s1">&#39;latitudes&#39;</span><span class="p">:[</span><span class="n">lat</span><span class="p">]},</span>
                            <span class="n">position_on_horizontal_grid</span><span class="o">=</span><span class="s1">&#39;center&#39;</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="D3Geometry.make_profile_geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.make_profile_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_profile_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a V1DGeometry at coordinates *(lon,lat)* in degrees.&quot;&quot;&quot;</span>
        <span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">,</span>
                                   <span class="n">typeoffirstfixedsurface</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
                                   <span class="n">levels</span><span class="o">=</span><span class="p">[])</span>
        <span class="k">return</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;V1D&#39;</span><span class="p">,</span>
                            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;unstructured&#39;</span><span class="p">,</span>
                            <span class="n">vcoordinate</span><span class="o">=</span><span class="n">vcoordinate</span><span class="p">,</span>
                            <span class="n">dimensions</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span>
                            <span class="n">grid</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;longitudes&#39;</span><span class="p">:[</span><span class="n">lon</span><span class="p">],</span>
                                  <span class="s1">&#39;latitudes&#39;</span><span class="p">:[</span><span class="n">lat</span><span class="p">]},</span>
                            <span class="n">position_on_horizontal_grid</span><span class="o">=</span><span class="s1">&#39;center&#39;</span>
                            <span class="p">)</span></div>

<div class="viewcode-block" id="D3Geometry.make_section_geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.make_section_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_section_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span>
                              <span class="n">points_number</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a V2DGeometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param points_number: defines the total number of horizontal points of the</span>
<span class="sd">          section (including ends). If None, defaults to a number computed from</span>
<span class="sd">          the *ends* and the *resolution*.</span>
<span class="sd">        :param resolution: defines the horizontal resolution to be given to the</span>
<span class="sd">          field. If None, defaults to the horizontal resolution of the field.</span>
<span class="sd">        :param position: defines the position of data in the grid (for projected grids only)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end2</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end2</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">position</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;center&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;position can only be None or &#39;center&#39; for non-projected geometries.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;only one of resolution and &quot;</span> <span class="o">+</span>
                               <span class="s2">&quot; points_number can be given.&quot;</span><span class="p">)</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span> <span class="o">+</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">resolution</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;ends&#39; are too near: pure&quot;</span> <span class="o">+</span>
                                   <span class="s2">&quot; interpolation between two gridpoints.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">points_number</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;points_number&#39; must be at least 2.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">points_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">points_number</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">transect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">points_number</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">points_number</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">transect</span> <span class="o">=</span> <span class="p">[</span><span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;cannot make a section with less than&quot;</span> <span class="o">+</span>
                               <span class="s2">&quot; 2 points.&quot;</span><span class="p">)</span>
        <span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">,</span>
                                   <span class="n">typeoffirstfixedsurface</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
                                   <span class="n">levels</span><span class="o">=</span><span class="p">[])</span>
        <span class="n">kwargs_geom</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;structure&#39;</span><span class="p">:</span><span class="s1">&#39;V2D&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="s1">&#39;unstructured&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;vcoordinate&#39;</span><span class="p">:</span><span class="n">vcoordinate</span><span class="p">,</span>
                       <span class="s1">&#39;dimensions&#39;</span><span class="p">:{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">transect</span><span class="p">),</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span>
                       <span class="s1">&#39;grid&#39;</span><span class="p">:{</span><span class="s1">&#39;longitudes&#39;</span><span class="p">:[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">transect</span><span class="p">],</span>
                               <span class="s1">&#39;latitudes&#39;</span><span class="p">:[</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">transect</span><span class="p">]},</span>
                       <span class="s1">&#39;position_on_horizontal_grid&#39;</span><span class="p">:</span><span class="s1">&#39;center&#39;</span> <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">position</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">:</span>
            <span class="n">kwargs_geom</span><span class="p">[</span><span class="s1">&#39;geoid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoid</span>
        <span class="k">return</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_geom</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Geometry.make_physicallevels_geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.make_physicallevels_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_physicallevels_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new geometry excluding levels with no physical meaning.</span>

<span class="sd">        :param getdata: if False returns a field without data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">typeoffirstfixedsurface</span> <span class="o">==</span> <span class="mi">118</span><span class="p">:</span>
            <span class="c1"># build vertical geometry</span>
            <span class="n">kwargs_vcoord</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;structure&#39;</span><span class="p">:</span><span class="s1">&#39;V&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;typeoffirstfixedsurface&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">typeoffirstfixedsurface</span><span class="p">,</span>
                             <span class="s1">&#39;position_on_grid&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">position_on_grid</span><span class="p">,</span>
                             <span class="s1">&#39;grid&#39;</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">grid</span><span class="p">),</span>
                             <span class="s1">&#39;levels&#39;</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)}</span>
            <span class="c1"># Suppression of levels above or under physical domain</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs_vcoord</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;gridlevels&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">kwargs_vcoord</span><span class="p">[</span><span class="s1">&#39;levels&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
            <span class="c1"># build geometry</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_vcoord</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">geometry</span></div>

<div class="viewcode-block" id="D3Geometry.make_zoom_geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.make_zoom_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_zoom_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">extra_10th</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an unstructured geometry with the points contained in *zoom*.</span>

<span class="sd">        :param zoom: a dict(lonmin=, lonmax=, latmin=, latmax=).</span>
<span class="sd">        :param extra_10th: if True, add 1/10th of the X/Y extension of the zoom</span>
<span class="sd">                           (only usefull for the regular_lonlat grid implementation).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">()</span>
        <span class="n">kwargs_zoomgeom</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;structure&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span>
                           <span class="s1">&#39;vcoordinate&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(),</span>
                           <span class="s1">&#39;position_on_horizontal_grid&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">position_on_horizontal_grid</span><span class="p">,</span>
                           <span class="s1">&#39;geoid&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">}</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">zoomlons</span> <span class="o">=</span> <span class="n">FPList</span><span class="p">([])</span>
        <span class="n">zoomlats</span> <span class="o">=</span> <span class="n">FPList</span><span class="p">([])</span>
        <span class="n">flat_indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmin&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmax&#39;</span><span class="p">]</span> <span class="ow">and</span> \
               <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmin&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmax&#39;</span><span class="p">]:</span>
                <span class="n">zoomlons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">zoomlats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lats</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">flat_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">zoomlons</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;zoom not in domain.&quot;</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">zoomlons</span><span class="p">),</span>
                                         <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;unstructured&#39;</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;longitudes&#39;</span><span class="p">:</span><span class="n">zoomlons</span><span class="p">,</span>
                                   <span class="s1">&#39;latitudes&#39;</span><span class="p">:</span><span class="n">zoomlats</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_zoomgeom</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_reshape_lonlat_4d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">nb_validities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make lons, lats grids 4D.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nb_validities</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nb_validities must be &gt;=1 when d4==True&quot;</span><span class="p">)</span>
        <span class="c1"># We add vertical dimension, and missing horizontal dimension</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lons</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shape</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)])</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">shape_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">shape_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>  <span class="c1"># last axis in first</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">shape_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>  <span class="c1"># last axis in first</span>
        <span class="c1"># We add validities</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">lons</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">nb_validities</span><span class="p">])</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">nb_validities</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">nb_validities</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">shape_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">shape_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>  <span class="c1"># last axis in first</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">shape_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape_range</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>  <span class="c1"># last axis in first</span>
        <span class="k">return</span> <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span>

<div class="viewcode-block" id="D3Geometry.eq_Hgeom"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.eq_Hgeom">[docs]</a>    <span class="k">def</span> <span class="nf">eq_Hgeom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests if the horizontal part of the geometry is equal to</span>
<span class="sd">        the horizontal part of another geometry.</span>
<span class="sd">        :param: other: other geometry to use in the comparison</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">D3Geometry</span><span class="p">),</span> <span class="s2">&quot;Other must be a geometry object&quot;</span>
        <span class="n">vc_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">vcoordinate</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">vc_self</span>
        <span class="k">return</span> <span class="n">result</span></div>

<span class="c1">###################</span>
<span class="c1"># PRE-APPLICATIVE #</span>
<span class="c1">###################</span>
<span class="c1"># (but useful and rather standard) !</span>
<span class="c1"># [so that, subject to continuation through updated versions,</span>
<span class="c1">#  including suggestions/developments by users...]</span>

<div class="viewcode-block" id="D3Geometry.make_field"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.make_field">[docs]</a>    <span class="k">def</span> <span class="nf">make_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a field out of the geometry.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">ll_field</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;H2D&#39;</span><span class="p">,</span>
                             <span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">fid</span><span class="o">=</span><span class="n">FPDict</span><span class="p">({</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="n">fid</span><span class="p">}))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]))</span>
        <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">ll_field</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ll_field</span></div>

<div class="viewcode-block" id="D3Geometry.plotgeometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.plotgeometry">[docs]</a>    <span class="k">def</span> <span class="nf">plotgeometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">plotlib</span><span class="o">=</span><span class="s1">&#39;cartopy&#39;</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a simple plot of the geometry, with a number of options.</span>

<span class="sd">        :param plotlib: library to be used for plotting: &#39;basemap&#39; is DEPRECATED;</span>
<span class="sd">            &#39;cartopy&#39; (default) is recommended !</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">plotlib</span> <span class="o">==</span> <span class="s1">&#39;cartopy&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cartoplot_geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;&#39;basemap&#39; plotlib has been removed, only remains &#39;cartopy&#39;&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Geometry.cartoplot_geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.cartoplot_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">cartoplot_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a simple plot of the geometry, using cartopy.</span>
<span class="sd">        For kwargs please refer to epygram.geometries.domain_making.output.cartoplot_rect_geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">epygram.geometries.domain_making.output</span> <span class="kn">import</span> <span class="n">cartoplot_rect_geometry</span>
        <span class="k">if</span> <span class="s1">&#39;color&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>  <span class="c1"># compatibility dirty-fix</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;contourcolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">cartoplot_rect_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="D3Geometry.what"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3Geometry.what">[docs]</a>    <span class="k">def</span> <span class="nf">what</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
             <span class="n">vertical_geometry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">arpifs_var_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">spectral_geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the geometry.</span>

<span class="sd">        :param out: the output open file-like object (duck-typing: *out*.write()</span>
<span class="sd">          only is needed).</span>
<span class="sd">        :param vertical_geometry: if True, writes the vertical geometry of the</span>
<span class="sd">          field.</span>
<span class="sd">        :param arpifs_var_names: if True, prints the equivalent &#39;arpifs&#39; variable</span>
<span class="sd">          names.</span>
<span class="sd">        :param spectral_geometry: an optional dict containing the spectral</span>
<span class="sd">          truncatures {&#39;in_X&#39;:, &#39;in_Y&#39;:}  (LAM) or {&#39;max&#39;:} (global).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;###########################</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;### HORIZONTAL GEOMETRY ###</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;###########################</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Rectangular grid ( = LAM or reg. Lon/Lat)&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">rectangular_grid</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_what_grid_dimensions</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">spectral_geometry</span><span class="o">=</span><span class="n">spectral_geometry</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rectangular_grid</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projected_geometry</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_what_projection</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">arpifs_var_names</span><span class="o">=</span><span class="n">arpifs_var_names</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;regular_lonlat&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_what_grid</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">arpifs_var_names</span><span class="o">=</span><span class="n">arpifs_var_names</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_lonlat&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_what_grid</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;academic&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_what_position</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;unstructured&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_what_grid</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">separation_line</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vertical_geometry</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">what</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="D3RectangularGridGeometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry">[docs]</a><span class="k">class</span> <span class="nc">D3RectangularGridGeometry</span><span class="p">(</span><span class="n">D3Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles the geometry for a rectangular 3-Dimensions Field.</span>
<span class="sd">    Abstract.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_abstract</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_collector</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,)</span>
    <span class="n">_footprint</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">attr</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;lambert&#39;</span><span class="p">,</span> <span class="s1">&#39;mercator&#39;</span><span class="p">,</span> <span class="s1">&#39;polar_stereographic&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;regular_lonlat&#39;</span><span class="p">,</span> <span class="s1">&#39;rotated_lonlat&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;academic&#39;</span><span class="p">,</span> <span class="s1">&#39;unstructured&#39;</span><span class="p">]))</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isglobal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: True if geometry is global</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Apart for global lon-lat</span>

    <span class="k">def</span> <span class="nf">_get_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indextype</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of two tables containing the two indexes of each</span>
<span class="sd">        point, with 2D shape.</span>

<span class="sd">        :param indextype: either &#39;ij&#39;, &#39;xy&#39; or &#39;ll&#39; to get</span>
<span class="sd">          i,j indexes, x,y coordinates or lon,lat coordinates</span>
<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, returns</span>
<span class="sd">          the grid resp. for the C or C+I zone off the C+I+E zone. \n</span>
<span class="sd">          Default is no subzone, i.e. the whole field.</span>
<span class="sd">        :param position: position of lonlat grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]),</span>
                                      <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]))</span>
        <span class="n">igrid</span> <span class="o">=</span> <span class="n">igrid</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">jgrid</span> <span class="o">=</span> <span class="n">jgrid</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">indextype</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">indextype</span> <span class="o">==</span> <span class="s1">&#39;ll&#39;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">indextype</span> <span class="o">==</span> <span class="s1">&#39;ij&#39;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;*indextype*== &#39;</span> <span class="o">+</span> <span class="n">indextype</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subzone</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_subzone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subzone</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_subzone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">subzone</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gridpoints_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of gridpoints of the grid.</span>

<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, returns</span>
<span class="sd">          the grid resp. for the C or C+I zone off the C+I+E zone. \n</span>
<span class="sd">          Default is no subzone, i.e. the whole field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">dimT</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">force_dimZ</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="D3RectangularGridGeometry.get_lonlat_grid"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.get_lonlat_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_lonlat_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">nb_validities</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">force_longitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of two tables containing one the longitude of each</span>
<span class="sd">        point, the other the latitude, with 2D shape.</span>

<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, returns</span>
<span class="sd">          the grid resp. for the C or C+I zone off the C+I+E zone. \n</span>
<span class="sd">          Default is no subzone, i.e. the whole field.</span>
<span class="sd">        :param position: position of lonlat grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        :param d4: - if True,  returned values are shaped in a 4 dimensions array</span>
<span class="sd">                   - if False, shape of returned values is determined with</span>
<span class="sd">                     respect to geometry. d4=True requires nb_validities &gt; 0</span>
<span class="sd">        :param nb_validities: number of validities represented in data values</span>
<span class="sd">        :param force_longitudes: if &#39;positive&#39;, the longitudes will be forced positive</span>
<span class="sd">                                 if &#39;]-180,180]&#39;, the longitudes will be in the ]-180, 180] interval</span>

<span class="sd">        Shape of 2D data on Rectangular grids: \n</span>
<span class="sd">          - grid[0,0] is SW, grid[-1,-1] is NE \n</span>
<span class="sd">          - grid[0,-1] is SE, grid[-1,0] is NW</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_grid</span><span class="p">(</span><span class="s1">&#39;ll&#39;</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d4</span><span class="p">:</span>
            <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_lonlat_4d</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">nb_validities</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">d4</span> <span class="ow">and</span> <span class="n">nb_validities</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;*nb_validities* must be 0 when d4==False&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">force_longitudes</span> <span class="o">==</span> <span class="s1">&#39;positive&#39;</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">positive_longitudes</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">force_longitudes</span> <span class="o">==</span> <span class="s1">&#39;]-180,180]&#39;</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">longitudes_between_minus180_180</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.extract_subzone"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.extract_subzone">[docs]</a>    <span class="k">def</span> <span class="nf">extract_subzone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">subzone</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts the subzone C or CI from a LAM field.</span>

<span class="sd">        :param data: the data values with shape concording with geometry.</span>
<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only,</span>
<span class="sd">          extracts the data resp. from the C or C+I zone off the C+I(+E) zone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subzone</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;CI&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;only possible values for &#39;subzone&#39; are &#39;C&#39;&quot;</span> <span class="o">+</span>
                               <span class="s2">&quot; or &#39;CI&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;LAMzone&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;method for LAM grids only.&quot;</span><span class="p">)</span>

        <span class="n">selectionE</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># To remove E-zone</span>
        <span class="n">selectionI</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># To eventually remove I-zone</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">selectionE</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">selectionI</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">selectionE</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="n">selectionI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]:</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span>
            <span class="n">selectionE</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span>
            <span class="n">selectionI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">y2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">y2</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span>
            <span class="n">selectionE</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span>
            <span class="n">selectionI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">x2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">x2</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CIE&#39;</span><span class="p">:</span>
            <span class="c1"># remove E-zone</span>
            <span class="n">edata</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">selectionE</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edata</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">if</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
            <span class="c1"># remove I-zone</span>
            <span class="n">edata</span> <span class="o">=</span> <span class="n">edata</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">selectionI</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">edata</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.make_subarray_geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.make_subarray_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_subarray_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">first_i</span><span class="p">,</span> <span class="n">last_i</span><span class="p">,</span>
                               <span class="n">first_j</span><span class="p">,</span> <span class="n">last_j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a modified geometry consisting in a subarray of the grid, defined</span>
<span class="sd">        by the indexes given as argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">first_i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">first_i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">last_i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">last_i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">first_j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">first_j</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="ow">or</span> \
           <span class="n">last_j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">last_j</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;first_i, last_i, first_j and last_j must be inside the geometry&quot;</span><span class="p">)</span>

        <span class="n">geom_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span><span class="p">)</span>
        <span class="n">geom_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dimensions&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;LAMzone&#39;</span> <span class="ow">in</span> <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]:</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;input_position&#39;</span> <span class="ow">in</span> <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]:</span>
            <span class="n">coords_00</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">first_i</span><span class="p">,</span> <span class="n">first_j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">input_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">coords_00</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span> <span class="k">else</span> <span class="n">coords_00</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">input_lat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">coords_00</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span> <span class="k">else</span> <span class="n">coords_00</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_lon</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_lat</span>
        <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="n">last_i</span> <span class="o">-</span> <span class="n">first_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="n">last_j</span> <span class="o">-</span> <span class="n">first_j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
        <span class="n">newgeom</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">geom_kwargs</span><span class="p">)</span>  <span class="c1"># create new geometry object</span>
        <span class="k">return</span> <span class="n">newgeom</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.make_subsample_geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.make_subsample_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_subsample_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_x</span><span class="p">,</span> <span class="n">sample_y</span><span class="p">,</span> <span class="n">sample_z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a sample geometry by decreasing resolution.</span>
<span class="sd">        :param sample_x: take one over &lt;sample_x&gt; points in the x direction</span>
<span class="sd">        :param sample_y: same for the y direction</span>
<span class="sd">        :param sample_z: same for the z direction</span>

<span class="sd">        CAUTION: if your grid contains non physical point, these points can be</span>
<span class="sd">        retain in subsample. Use select_zone beforehand to suppress these points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_y</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_z</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;sample_x, y and z must be integers&quot;</span>
        <span class="n">geom_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;LAMzone&#39;</span> <span class="ow">in</span> <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]:</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;input_position&#39;</span> <span class="ow">in</span> <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]:</span>
            <span class="n">coords_00</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">input_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">coords_00</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span> <span class="k">else</span> <span class="n">coords_00</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">input_lat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">coords_00</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span> <span class="k">else</span> <span class="n">coords_00</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_lon</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_lat</span>
        <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">][</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample_x</span><span class="p">))),</span>
                                     <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">][</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sample_y</span><span class="p">)))}</span>
        <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_x</span>
        <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_y</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;vcoordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">levels</span><span class="p">[::</span><span class="n">sample_z</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;vcoordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">levels</span><span class="p">[:]</span>
        <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;vcoordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">levels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">newgeom</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">geom_kwargs</span><span class="p">)</span>  <span class="c1"># create new geometry object</span>
        <span class="k">return</span> <span class="n">newgeom</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.get_datashape"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.get_datashape">[docs]</a>    <span class="k">def</span> <span class="nf">get_datashape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">dimT</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                      <span class="n">force_dimZ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the data shape according to the geometry.</span>

<span class="sd">        :param force_dimZ: if supplied, force the Z dimension instead of that</span>
<span class="sd">          of the vertical geometry</span>
<span class="sd">        :param dimT: if supplied, is the time dimension to be added to the</span>
<span class="sd">          data shape</span>
<span class="sd">        :param d4: - if True,  shape is 4D</span>
<span class="sd">                   - if False, shape has only those &gt; 1</span>
<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, informes that</span>
<span class="sd">          data is resp. on the C or C+I zone off the C+I(+E) zone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subzone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
            <span class="n">dimY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> \
                <span class="s2">&quot;*subzone* cannot be requested for this geometry&quot;</span>
            <span class="k">assert</span> <span class="n">subzone</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;CI&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CIE&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;CI&#39;</span><span class="p">:</span>
                    <span class="n">dimX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span>
                    <span class="n">dimY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                    <span class="n">dimX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span>
                    <span class="n">dimY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CI&#39;</span><span class="p">:</span>
                <span class="n">dimX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span>
                <span class="n">dimY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">force_dimZ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimZ</span> <span class="o">=</span> <span class="n">force_dimZ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimZ</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d4</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimT</span><span class="p">,</span> <span class="n">dimZ</span><span class="p">,</span> <span class="n">dimY</span><span class="p">,</span> <span class="n">dimX</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">dimT</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimT</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dimZ</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimZ</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]:</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimY</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]:</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimX</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.reshape_data"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.reshape_data">[docs]</a>    <span class="k">def</span> <span class="nf">reshape_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
                     <span class="n">first_dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 2D data (horizontal dimensions) reshaped from 1D,</span>
<span class="sd">        according to geometry.</span>

<span class="sd">        :param data: the 1D data (or 3D with a T and Z dimensions,</span>
<span class="sd">          or 2D with either a T/Z dimension, to be specified),</span>
<span class="sd">          of dimension concording with geometry. In case data is 3D, T must be</span>
<span class="sd">          first dimension and Z the second.</span>
<span class="sd">        :param first_dimension: in case data is 2D, specify what is the first</span>
<span class="sd">          dimension of data among (&#39;T&#39;, &#39;Z&#39;)</span>
<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, informes that</span>
<span class="sd">          data is resp. on the C or C+I zone off the C+I(+E) zone.</span>
<span class="sd">        :param d4: - if True,  returned values are shaped in a 4 dimensions array</span>
<span class="sd">                   - if False, shape of returned values is determined with respect to geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span>
        <span class="n">shp_in</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">nb_levels</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">nb_validities</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">first_dimension</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">),</span> \
                <span class="s2">&quot;*first_dimension* must be among (&#39;T&#39;, &#39;Z&#39;) if *data*.shape == 2&quot;</span>
            <span class="k">if</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
                <span class="n">nb_validities</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
                <span class="n">nb_levels</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">nb_validities</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nb_levels</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">nb_levels</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)),</span> \
               <span class="s2">&quot;vertical dimension of data must be 1 or self.vcoordinate.levels=&quot;</span> \
               <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d4</span> <span class="ow">or</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">nb_validities</span><span class="p">,</span> <span class="n">nb_levels</span><span class="p">):</span>  <span class="c1"># data as 4D or truly 4D</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">dimT</span><span class="o">=</span><span class="n">nb_validities</span><span class="p">,</span> <span class="n">force_dimZ</span><span class="o">=</span><span class="n">nb_levels</span><span class="p">,</span>
                                     <span class="n">d4</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">dimT</span><span class="o">=</span><span class="n">nb_validities</span><span class="p">,</span> <span class="n">force_dimZ</span><span class="o">=</span><span class="n">nb_levels</span><span class="p">,</span>
                                     <span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.horizontally_flattened"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.horizontally_flattened">[docs]</a>    <span class="k">def</span> <span class="nf">horizontally_flattened</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of *data* with horizontal dimensions flattened.</span>
<span class="sd">        *data* must be 4D for simplicity reasons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
        <span class="n">data3D</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gridpoints_number</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">data3D</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data3D</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.fill_maskedvalues"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.fill_maskedvalues">[docs]</a>    <span class="k">def</span> <span class="nf">fill_maskedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of *data* with masked values filled with *fill_value*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.gimme_corners_ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.gimme_corners_ij">[docs]</a>    <span class="k">def</span> <span class="nf">gimme_corners_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the indices (i, j) of the four corners of a rectangular grid,</span>
<span class="sd">        as a dict(corner=(i, j)) with corner in: \n</span>
<span class="sd">        ll = lower-left / lr = lower-right / ur = upper-right / ul = upper-left.</span>

<span class="sd">        (0, 0) is always the lower-left corner of the grid.</span>

<span class="sd">        :param subzone: for LAM fields, returns the corners of the subzone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;LAMzone&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CIE&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subzone</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;CIE&#39;</span><span class="p">):</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;CI&#39;</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">])</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">])</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CI&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subzone</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;CI&#39;</span><span class="p">):</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">lr</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">ul</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">],</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">ur</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Czone&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;ll&#39;</span><span class="p">:</span><span class="n">ll</span><span class="p">,</span> <span class="s1">&#39;lr&#39;</span><span class="p">:</span><span class="n">lr</span><span class="p">,</span> <span class="s1">&#39;ul&#39;</span><span class="p">:</span><span class="n">ul</span><span class="p">,</span> <span class="s1">&#39;ur&#39;</span><span class="p">:</span><span class="n">ur</span><span class="p">}</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.gimme_corners_ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.gimme_corners_ll">[docs]</a>    <span class="k">def</span> <span class="nf">gimme_corners_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the lon/lat of the four corners of a rectangular grid,</span>
<span class="sd">        as a dict(corner=(lon, lat)) with corner in: \n</span>
<span class="sd">        ll = lower-left / lr = lower-right / ur = upper-right / ul = upper-left.</span>

<span class="sd">        :param subzone: for LAM grids, returns the corners of the subzone.</span>
<span class="sd">        :param position: position of corners with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">corners</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">corners</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">corners</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">corners</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.minmax_ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.minmax_ll">[docs]</a>    <span class="k">def</span> <span class="nf">minmax_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return min/max of lon/lat.&quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">jmin</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ll&#39;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">imax</span><span class="p">,</span> <span class="n">jmax</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ur&#39;</span><span class="p">]</span>
        <span class="n">border</span> <span class="o">=</span> <span class="p">[(</span><span class="n">imin</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> \
                 <span class="p">[(</span><span class="n">imax</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jmin</span><span class="p">,</span> <span class="n">jmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> \
                 <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">jmin</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">imax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> \
                 <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">jmax</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">imax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">ilist</span><span class="p">,</span> <span class="n">jlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">border</span><span class="p">))</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ilist</span><span class="p">),</span>
                                  <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jlist</span><span class="p">))</span>
        <span class="n">lonmin</span><span class="p">,</span> <span class="n">lonmax</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">lons</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">latmin</span><span class="p">,</span> <span class="n">latmax</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">lats</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked</span> <span class="ow">in</span> <span class="p">(</span><span class="n">lonmin</span><span class="p">,</span> <span class="n">lonmax</span><span class="p">,</span> <span class="n">latmin</span><span class="p">,</span> <span class="n">latmax</span><span class="p">):</span>
            <span class="c1">#space-view geometry for example</span>
            <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">)</span>
            <span class="n">lonmin</span><span class="p">,</span> <span class="n">lonmax</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">lons</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">latmin</span><span class="p">,</span> <span class="n">latmax</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">lats</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;lonmin&#39;</span><span class="p">:</span><span class="n">lonmin</span><span class="p">,</span> <span class="s1">&#39;lonmax&#39;</span><span class="p">:</span><span class="n">lonmax</span><span class="p">,</span>
                <span class="s1">&#39;latmin&#39;</span><span class="p">:</span><span class="n">latmin</span><span class="p">,</span> <span class="s1">&#39;latmax&#39;</span><span class="p">:</span><span class="n">latmax</span><span class="p">}</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.point_is_inside_domain_ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.point_is_inside_domain_ll">[docs]</a>    <span class="k">def</span> <span class="nf">point_is_inside_domain_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span>
                                  <span class="n">margin</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span>
                                  <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the point(s) of lon/lat coordinates is(are) inside the</span>
<span class="sd">        field.</span>

<span class="sd">        :param lon: longitude of point(s) in degrees.</span>
<span class="sd">        :param lat: latitude of point(s) in degrees.</span>
<span class="sd">        :param margin: considers the point inside if at least &#39;margin&#39; points far</span>
<span class="sd">          from the border. The -0.1 default is a safety for precision errors.</span>
<span class="sd">        :param subzone: considers only a subzone among (&#39;C&#39;, &#39;CI&#39;) of the domain.</span>
<span class="sd">        :param position: position of the grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">Xmin</span><span class="p">,</span> <span class="n">Ymin</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ll&#39;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">Xmax</span><span class="p">,</span> <span class="n">Ymax</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ur&#39;</span><span class="p">]</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Xmin</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                     <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Xmax</span> <span class="o">-</span> <span class="n">margin</span><span class="p">),</span>
                                   <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Ymin</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                     <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Ymax</span> <span class="o">-</span> <span class="n">margin</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">inside</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.point_is_inside_domain_ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.point_is_inside_domain_ij">[docs]</a>    <span class="k">def</span> <span class="nf">point_is_inside_domain_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">i</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">j</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">margin</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span>
                                  <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the point(s) of i/j coordinates is(are) inside the</span>
<span class="sd">        field.</span>

<span class="sd">        :param i: X index of point</span>
<span class="sd">        :param j: Y index of point.</span>
<span class="sd">        :param margin: considers the point inside if at least &#39;margin&#39; points far</span>
<span class="sd">          from the border. The -0.1 default is a safety for precision errors.</span>
<span class="sd">        :param subzone: considers only a subzone among (&#39;C&#39;, &#39;CI&#39;) of the domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;*j* is mandatory when field has a two horizontal dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;*i* is mandatory when field has one horizontal dimension&quot;</span><span class="p">)</span>

        <span class="p">(</span><span class="n">Xmin</span><span class="p">,</span> <span class="n">Ymin</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ll&#39;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">Xmax</span><span class="p">,</span> <span class="n">Ymax</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ij</span><span class="p">(</span><span class="n">subzone</span><span class="p">)[</span><span class="s1">&#39;ur&#39;</span><span class="p">]</span>

        <span class="n">i</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inside_i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Xmin</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">,</span>
                                         <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">Xmax</span> <span class="o">-</span> <span class="n">margin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">j</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inside_j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">Ymin</span> <span class="o">+</span> <span class="n">margin</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">,</span>
                                         <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">Ymax</span> <span class="o">-</span> <span class="n">margin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="n">inside_j</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="n">inside_i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inside</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">inside_i</span><span class="p">,</span> <span class="n">inside_j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inside</span></div>

<div class="viewcode-block" id="D3RectangularGridGeometry.nearest_points"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RectangularGridGeometry.nearest_points">[docs]</a>    <span class="k">def</span> <span class="nf">nearest_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span>
                       <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">external_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">squeeze</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the (i, j) positions of the nearest points.</span>

<span class="sd">        :param lon: longitude of point in degrees.</span>
<span class="sd">        :param lat: latitude of point in degrees.</span>
<span class="sd">        :param request: criteria for selecting the points, among:</span>
<span class="sd">               * {&#39;n&#39;:&#39;1&#39;} - the nearest point</span>
<span class="sd">               * {&#39;n&#39;:&#39;2*2&#39;} - the 2*2 square points around the position</span>
<span class="sd">               * {&#39;n&#39;:&#39;4*4&#39;} - the 4*4 square points around the position</span>
<span class="sd">               * {&#39;n&#39;:&#39;N*N&#39;} - the N*N square points around the position: N must be even</span>
<span class="sd">               * {&#39;radius&#39;:xxxx, &#39;shape&#39;:&#39;square&#39;} - the points which are xxxx metres</span>
<span class="sd">                 around the position in X or Y direction</span>
<span class="sd">               * {&#39;radius&#39;:xxxx, &#39;shape&#39;:&#39;circle&#39;} - the points within xxxx metres</span>
<span class="sd">                 around the position. (default shape == circle)</span>
<span class="sd">        :param position: position in the model cell of the lat lon position.</span>
<span class="sd">               Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        :param external_distance: can be a dict containing the target point value</span>
<span class="sd">                and an external field on the same grid as self, to which the distance</span>
<span class="sd">                is computed within the 4 horizontally nearest points; e.g.</span>
<span class="sd">                {&#39;target_value&#39;:4810, &#39;external_field&#39;:a_3DField_with_same_geometry}.</span>
<span class="sd">                If so, the nearest point is selected with</span>
<span class="sd">                distance = |target_value - external_field.data|</span>
<span class="sd">                Only valid with request={&#39;n&#39;:&#39;1&#39;}</span>
<span class="sd">        :param squeeze: True to suppress useless dimensions</span>

<span class="sd">        :rtype: general output form is [list, list, ..., list]</span>
<span class="sd">                with as many list items as the length of lon/lat.</span>
<span class="sd">                Each list item is of the form [tuple, tuple, ..., tuple]</span>
<span class="sd">                with as many tuples as the request implies. A tuple</span>
<span class="sd">                represents one of the nearest points associated with one</span>
<span class="sd">                value taken from lon/lat. Each tuple as the form</span>
<span class="sd">                (i, j).</span>

<span class="sd">                Dimensions with a length of one are removed except if</span>
<span class="sd">                squeeze is False. If squeeze is True and if request</span>
<span class="sd">                implies only one nearest point, the list item of the general</span>
<span class="sd">                output form is replaced by the tuple item; if length of</span>
<span class="sd">                lon/lat is one, the output is directly the list item of</span>
<span class="sd">                the general output form. Hence, if length of lon/lat is</span>
<span class="sd">                one and the request implies only one point, the output is</span>
<span class="sd">                a tuple.</span>

<span class="sd">                In case of a simple square request, output is actually</span>
<span class="sd">                an array. Otherwise, the output is as described (it cannot</span>
<span class="sd">                be an array because the number of nearest points can vary</span>
<span class="sd">                with the entry point).</span>

<span class="sd">        In case of a {&#39;n&#39;:&#39;2*2&#39;} request, order of points obtained on a rectangular grid is</span>
<span class="sd">        (and must be) such that first and second point share the i position (hence</span>
<span class="sd">        third and forth point also share the i position) and first and third share the j</span>
<span class="sd">        position (hence the second and forth also share the j position).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_is_inside_domain_ll</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;point (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">+</span>
                             <span class="s2">&quot;) is out of field domain.&quot;</span><span class="p">)</span>

        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">j0</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="n">i_int</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="n">j_int</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">j0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="n">nsquare_match</span> <span class="o">=</span> <span class="n">_re_nearest_sq</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nsquare_match</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">),</span> \
                <span class="s2">&quot;anisotropic request {&#39;n&#39;:&#39;N*M&#39;} is not supported.&quot;</span>
        <span class="k">if</span> <span class="n">external_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">request</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="s1">&#39;1&#39;</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">_increments</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;academic&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">i_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;academic&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">j_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">i_incr</span><span class="p">,</span> <span class="n">j_incr</span><span class="p">)</span>

        <span class="c1"># compute points position</span>
        <span class="k">if</span> <span class="n">request</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="s1">&#39;1&#39;</span><span class="p">}</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">external_distance</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">i0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">),</span>
                       <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">j0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># square: size</span>
            <span class="k">if</span> <span class="n">external_distance</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">):</span>
                <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">resolution</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nsquare_match</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;unrecognized **request**: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">request</span><span class="p">))</span>
            <span class="c1"># square: indexes</span>
            <span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">)</span> <span class="o">=</span> <span class="n">_increments</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="p">[</span><span class="n">i_int</span> <span class="o">+</span> <span class="n">di</span> <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">ii</span><span class="p">]</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="p">[</span><span class="n">j_int</span> <span class="o">+</span> <span class="n">dj</span> <span class="k">for</span> <span class="n">dj</span> <span class="ow">in</span> <span class="n">jj</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ii</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">jj</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># filter: if external distance</span>
            <span class="k">if</span> <span class="n">external_distance</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># We transform into list to be able to modify the length</span>
                <span class="k">for</span> <span class="n">ipt</span><span class="p">,</span> <span class="n">points</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                    <span class="n">mindistance</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">external_distance</span><span class="p">[</span><span class="s1">&#39;external_field&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getvalue_ij</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">one</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="n">external_distance</span><span class="p">[</span><span class="s1">&#39;target_value&#39;</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">mindistance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">mindistance</span><span class="p">:</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
                            <span class="n">mindistance</span> <span class="o">=</span> <span class="n">dist</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># all item must now have the same length</span>

        <span class="c1"># filter: if radius</span>
        <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># We transform into list to be able to modify the length</span>
            <span class="k">for</span> <span class="n">ipt</span><span class="p">,</span> <span class="n">points</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;circle&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;circle&#39;</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">points</span>
                                   <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">((</span><span class="n">lon</span><span class="p">[</span><span class="n">ipt</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">ipt</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;square&#39;</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">points</span>
                                   <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="n">lon</span><span class="p">[</span><span class="n">ipt</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">ipt</span><span class="p">]))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)))</span> <span class="o">&lt;=</span> <span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">])]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;no points found: radius may be too small.&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_is_inside_domain_ij</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]))):</span>
                    <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;one point (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">+</span>
                                       <span class="s2">&quot;) too close to field domain borders.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">squeeze</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># check all points in domain</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_is_inside_domain_ij</span><span class="p">(</span><span class="o">*</span><span class="n">point</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;one point (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">+</span>
                                       <span class="s2">&quot;) too close to field domain borders.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span> <span class="nf">_what_grid_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
                              <span class="n">arpifs_var_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                              <span class="n">spectral_geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the grid &amp; dimensions of the field.</span>

<span class="sd">        :param out: the output open file-like object</span>
<span class="sd">        :param arpifs_var_names: if True, prints the equivalent &#39;arpifs&#39; variable</span>
<span class="sd">          names.</span>
<span class="sd">        :param spectral_geometry: an optional dict containing the spectral</span>
<span class="sd">          truncatures {&#39;in_X&#39;:, &#39;in_Y&#39;:}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="k">if</span> <span class="s1">&#39;LAMzone&#39;</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">:</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Zone&quot;</span><span class="p">,</span> <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NDLON)&#39;</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Total points in X&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                            <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NDGL)&#39;</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Total points in Y&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                            <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CIE&#39;</span><span class="p">:</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Points of C+I in X&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">])</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Points of C+I in Y&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NDLUN-1)&#39;</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                                <span class="s2">&quot;Low-left X offset for I zone&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NDGUN-1)&#39;</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                                <span class="s2">&quot;Low-left Y offset for I zone&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">])</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Width of I strip in X&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Width of I strip in Y&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CI&#39;</span><span class="p">:</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Width of I strip in X&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">])</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Width of I strip in Y&quot;</span><span class="p">,</span>
                                <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">spectral_geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NMSMAX)&#39;</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Truncation in X&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                                <span class="n">spectral_geometry</span><span class="p">[</span><span class="s1">&#39;in_X&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NSMAX)&#39;</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Truncation in Y&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                                <span class="n">spectral_geometry</span><span class="p">[</span><span class="s1">&#39;in_Y&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (NDLON)&#39;</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Total points in X&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                            <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Total points in Y&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                            <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span>
        <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">separation_line</span><span class="p">)</span>

    <span class="c1">#FIXME: cleanme def __eq__(self, other):</span>
    <span class="c1">#    &quot;&quot;&quot;Test of equality by recursion on the object&#39;s attributes.&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;    if self.__class__ == other.__class__ and \</span>
<span class="sd">           set(self._attributes.keys()) == set(other._attributes.keys()):</span>
<span class="sd">            for attr in self._attributes.keys():</span>
<span class="sd">                if attr == &#39;grid&#39;:</span>
<span class="sd">                    # the same grid could be defined from different inputs</span>
<span class="sd">                    selfgrid = {k:v for k, v in self.grid.items() if</span>
<span class="sd">                                k not in [&#39;input_lon&#39;,</span>
<span class="sd">                                          &#39;input_lat&#39;,</span>
<span class="sd">                                          &#39;input_position&#39;]}</span>
<span class="sd">                    othergrid = {k:v for k, v in self.grid.items() if</span>
<span class="sd">                                 k not in [&#39;input_lon&#39;,</span>
<span class="sd">                                           &#39;input_lat&#39;,</span>
<span class="sd">                                           &#39;input_position&#39;]}</span>
<span class="sd">                    ok = (selfgrid == othergrid and</span>
<span class="sd">                          self.getcenter() == other.getcenter())</span>
<span class="sd">                else:</span>
<span class="sd">                    ok = self._attributes[attr] == other._attributes[attr]</span>
<span class="sd">                if not ok:</span>
<span class="sd">                    break</span>
<span class="sd">        else:</span>
<span class="sd">            ok = False</span>
<span class="sd">        return ok</span>

<span class="sd">    def __hash__(self):</span>
<span class="sd">        # known issue __eq__/must be defined both or none, else inheritance is broken</span>
<span class="sd">        return super(D3RectangularGridGeometry, self).__hash__()&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="D3UnstructuredGeometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3UnstructuredGeometry">[docs]</a><span class="k">class</span> <span class="nc">D3UnstructuredGeometry</span><span class="p">(</span><span class="n">D3RectangularGridGeometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Handles the geometry for an unstructured 3-Dimensions Field.&quot;&quot;&quot;</span>

    <span class="n">_collector</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,)</span>
    <span class="n">_footprint</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">attr</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;unstructured&#39;</span><span class="p">])),</span>
            <span class="n">position_on_horizontal_grid</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">default</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                <span class="n">values</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;center&#39;</span><span class="p">])),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">D3UnstructuredGeometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_consistency_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that the geometry is consistent.&quot;&quot;&quot;</span>
        <span class="n">grid_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">,</span> <span class="s1">&#39;longitudes&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;DDH_domain&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;grid attribute must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; or &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">([</span><span class="s1">&#39;DDH_domain&#39;</span><span class="p">]))</span>

<div class="viewcode-block" id="D3UnstructuredGeometry.get_lonlat_grid"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3UnstructuredGeometry.get_lonlat_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_lonlat_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">nb_validities</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">force_longitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of two tables containing one the longitude of each</span>
<span class="sd">        point, the other the latitude, with 2D shape.</span>

<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, returns</span>
<span class="sd">          the grid resp. for the C or C+I zone off the C+I+E zone. \n</span>
<span class="sd">          Default is no subzone, i.e. the whole field.</span>
<span class="sd">        :param position: position of lonlat grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        :param d4: - if True,  returned values are shaped in a 4 dimensions array</span>
<span class="sd">                   - if False, shape of returned values is determined with respect to geometry.</span>
<span class="sd">                       d4=True requires nb_validities &gt; 0</span>
<span class="sd">        :param nb_validities: number of validities represented in data values</span>
<span class="sd">        :param force_longitudes: if &#39;positive&#39;, the longitudes will be forced positive</span>
<span class="sd">                                 if &#39;]-180,180]&#39;, the longitudes will be in the ]-180, 180] interval</span>

<span class="sd">        Shape of 2D data on Rectangular grids: \n</span>
<span class="sd">          - grid[0,0] is SW, grid[-1,-1] is NE \n</span>
<span class="sd">          - grid[0,-1] is SE, grid[-1,0] is NW</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s1">&#39;We can only retrieve latitude and longitude of mass point on an unstructured grid&#39;</span><span class="p">)</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;longitudes&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lons</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subzone</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_subzone</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">subzone</span><span class="p">)</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_subzone</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">subzone</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d4</span><span class="p">:</span>
            <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_lonlat_4d</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">nb_validities</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">d4</span> <span class="ow">and</span> <span class="n">nb_validities</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;*nb_validities* must be 0 when d4==False&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">force_longitudes</span> <span class="o">==</span> <span class="s1">&#39;positive&#39;</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">positive_longitudes</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">force_longitudes</span> <span class="o">==</span> <span class="s1">&#39;]-180,180]&#39;</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">longitudes_between_minus180_180</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3UnstructuredGeometry.ij2ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3UnstructuredGeometry.ij2ll">[docs]</a>    <span class="k">def</span> <span class="nf">ij2ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (lon, lat) coordinates of point *(i,j)*, in degrees.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lons</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;j must be 0 when geometry does not contain j dimension&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">lons</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lats</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">lons</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">lats</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span></div>

<div class="viewcode-block" id="D3UnstructuredGeometry.ll2ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3UnstructuredGeometry.ll2ij">[docs]</a>    <span class="k">def</span> <span class="nf">ll2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (i, j) indexes of point *(lon, lat)* in degrees,</span>
<span class="sd">        in the 2D matrix of gridpoints.</span>

<span class="sd">        :param lon: longitude of point in degrees</span>
<span class="sd">        :param lat: latitude of point in degrees</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Caution: the returned (*i,j*) are float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)):</span>
            <span class="n">where</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lons</span> <span class="o">-</span> <span class="n">lon</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lats</span> <span class="o">-</span> <span class="n">lat</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">where</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;No point found with these coordinates.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">where</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;Several points have the same coordinates.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]:</span>
                <span class="n">i</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">j</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">where</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">where</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">j</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span></div>

<div class="viewcode-block" id="D3UnstructuredGeometry.nearest_points"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3UnstructuredGeometry.nearest_points">[docs]</a>    <span class="k">def</span> <span class="nf">nearest_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span>
                       <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">external_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">squeeze</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the (i, j) position of the points needed to perform an</span>
<span class="sd">        interpolation. This is a list of (lon, lat) tuples.</span>

<span class="sd">        :param lon: longitude of point in degrees.</span>
<span class="sd">        :param lat: latitude of point in degrees.</span>
<span class="sd">        :param request: criteria for selecting the points, among:</span>
<span class="sd">               * {&#39;n&#39;:&#39;1&#39;} - the nearest point</span>
<span class="sd">        :param position: position in the model cell of the lat lon position.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        :param external_distance: can be a dict containing the target point value</span>
<span class="sd">          and an external field on the same grid as self, to which the distance</span>
<span class="sd">          is computed within the 4 horizontally nearest points; e.g.</span>
<span class="sd">          {&#39;target_value&#39;:4810, &#39;external_field&#39;:a_3DField_with_same_geometry}.</span>
<span class="sd">          If so, the nearest point is selected with</span>
<span class="sd">          distance = |target_value - external_field.data|</span>
<span class="sd">        :param squeeze: True to suppress useless dimensions</span>

<span class="sd">        :rtype: general output form is [list, list, ..., list]</span>
<span class="sd">                with as many list items as the length of lon/lat.</span>
<span class="sd">                Each list item is of the form [tuple, tuple, ..., tuple]</span>
<span class="sd">                with as many tuples as the request implies. A tuple</span>
<span class="sd">                represents one of the nearest points associated with one</span>
<span class="sd">                value taken from lon/lat. Each tuple as the form</span>
<span class="sd">                (i, j).</span>

<span class="sd">                Dimensions with a length of one are removed except if</span>
<span class="sd">                squeeze is False. If squeeze is True and if request</span>
<span class="sd">                implies only one nearest point, the list item of the general</span>
<span class="sd">                output form is replaced by the tuple item; if length of</span>
<span class="sd">                lon/lat is one, the output is directly the list item of</span>
<span class="sd">                the general output form. Hence, if length of lon/lat is</span>
<span class="sd">                one and the request implies only one point, the output is</span>
<span class="sd">                a tuple.</span>

<span class="sd">                In case of a simple square request, output is actually</span>
<span class="sd">                an array. Otherwise, the output is as described (it cannot</span>
<span class="sd">                be an array because the number of nearest points can vary</span>
<span class="sd">                with the entry point).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">request</span> <span class="o">!=</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="s1">&#39;1&#39;</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;*request* != &#39;{&#39;n&#39;:&#39;1&#39;}&#39; for UnstructuredGeometry.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">external_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;*external_distance* is not None for UnstructuredGeometry.&quot;</span><span class="p">)</span>

        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">one_lon</span><span class="p">,</span> <span class="n">one_lat</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">one_lon</span> <span class="o">-</span> <span class="n">lons</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">one_lat</span> <span class="o">-</span> <span class="n">lats</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">lons</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lons</span><span class="o">.</span><span class="n">shape</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="D3UnstructuredGeometry.resolution_ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3UnstructuredGeometry.resolution_ll">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local resolution at the nearest point of lon/lat.</span>
<span class="sd">        It&#39;s the distance between this point and its closest neighbour.</span>

<span class="sd">        :param lon: longitude of point in degrees.</span>
<span class="sd">        :param lat: latitude of point in degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">near_point</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nearest_points</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="s1">&#39;1&#39;</span><span class="p">}),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ij</span><span class="p">(</span><span class="o">*</span><span class="n">near_point</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3UnstructuredGeometry.resolution_ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3UnstructuredGeometry.resolution_ij">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance to the nearest point of (i,j) point.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="s2">&quot;Both coordinates must have the same length&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">((</span><span class="n">lons</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="n">k</span><span class="p">]],</span> <span class="n">lats</span><span class="p">[</span><span class="n">j</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="n">k</span><span class="p">]]),</span>
                                 <span class="p">(</span><span class="n">stretch_array</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="n">stretch_array</span><span class="p">(</span><span class="n">lats</span><span class="p">)))</span>
            <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">dist</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>

<div class="viewcode-block" id="D3UnstructuredGeometry.getcenter"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3UnstructuredGeometry.getcenter">[docs]</a>    <span class="k">def</span> <span class="nf">getcenter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinate of the grid center as a tuple of Angles</span>
<span class="sd">        (center_lon, center_lat).</span>

<span class="sd">        Caution: this is computed as the raw average of all grid points.</span>
<span class="sd">        A barycentric computation would be more adequate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Angle</span><span class="p">(</span><span class="n">lons</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                <span class="n">Angle</span><span class="p">(</span><span class="n">lats</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="s1">&#39;degrees&#39;</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_what_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the grid of the field.</span>

<span class="sd">        :param out: the output open file-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">()</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ll</span><span class="p">()</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Kind of Geometry&quot;</span><span class="p">,</span> <span class="s1">&#39;Unstructured&#39;</span><span class="p">)</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Max Longitude in deg&quot;</span><span class="p">,</span> <span class="n">lons</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Min Longitude in deg&quot;</span><span class="p">,</span> <span class="n">lons</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Max Latitude in deg&quot;</span><span class="p">,</span> <span class="n">lats</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Min Latitude in deg&quot;</span><span class="p">,</span> <span class="n">lats</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Left corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ll&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Left corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ll&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Right corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Right corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Left corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ul&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Left corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ul&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Right corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Right corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="D3AcademicGeometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry">[docs]</a><span class="k">class</span> <span class="nc">D3AcademicGeometry</span><span class="p">(</span><span class="n">D3RectangularGridGeometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Handles the geometry for an academic 3-Dimensions Field.&quot;&quot;&quot;</span>

    <span class="n">_collector</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,)</span>
    <span class="n">_footprint</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">attr</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;academic&#39;</span><span class="p">])),</span>
            <span class="n">projection</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">FPDict</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="s2">&quot;Handles projection information.&quot;</span><span class="p">),</span>
            <span class="n">geoid</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">FPDict</span><span class="p">,</span>
                <span class="n">optional</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="n">FPDict</span><span class="p">({}),</span>
                <span class="n">info</span><span class="o">=</span><span class="s2">&quot;Of no meaning in this geometry.&quot;</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">D3RectangularGridGeometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;For now, only input_position = (0, 0) is allowed for academic geometries.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>

<div class="viewcode-block" id="D3AcademicGeometry.tolerant_equal"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.tolerant_equal">[docs]</a>    <span class="k">def</span> <span class="nf">tolerant_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">epsilon</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="c1"># create copies of inner objects to filter some ghost attributes</span>
            <span class="n">almost_self</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                           <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ghost_attributes</span><span class="p">}</span>
            <span class="n">almost_other</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_ghost_attributes</span><span class="p">}</span>
            <span class="c1"># (the same grid could be defined from different inputs)</span>
            <span class="k">for</span> <span class="n">almost</span> <span class="ow">in</span> <span class="p">(</span><span class="n">almost_self</span><span class="p">,</span> <span class="n">almost_other</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;input_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;input_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;input_position&#39;</span><span class="p">):</span>
                    <span class="n">almost</span><span class="p">[</span><span class="s1">&#39;_attributes&#39;</span><span class="p">][</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">almost_self</span><span class="p">[</span><span class="s1">&#39;_attributes&#39;</span><span class="p">][</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getcenter</span><span class="p">()</span>
            <span class="n">almost_other</span><span class="p">[</span><span class="s1">&#39;_attributes&#39;</span><span class="p">][</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">getcenter</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Comparator</span><span class="o">.</span><span class="n">are_equal</span><span class="p">(</span><span class="n">almost_self</span><span class="p">,</span> <span class="n">almost_other</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">_rotate_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used to rotate x/y coordinates to handle rotated geometries.</span>
<span class="sd">        *direction*, if evals to &#39;xy2ll&#39;, direction used when converting (x, y) to (lat, lon).</span>
<span class="sd">                     if evals to &#39;ll2xy&#39;, direction used when converting (lat, lon) to (x, y).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;rotation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;rotation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;xy2ll&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">),</span>
                        <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;ll2xy&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span>
                        <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s1">&#39;Wrong direction of rotation.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_consistency_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that the geometry is consistent.&quot;&quot;&quot;</span>
        <span class="n">grid_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">,</span> <span class="s1">&#39;X_resolution&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_resolution&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;input_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;input_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;input_position&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grid_keys</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;grid attribute must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; or &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">grid_keys</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">,</span> <span class="s1">&#39;latitude&#39;</span><span class="p">]))</span>
        <span class="n">LAMzone_values</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;CI&#39;</span><span class="p">,</span> <span class="s1">&#39;CIE&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">LAMzone_values</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;grid[&#39;LAMzone&#39;] must be among &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">LAMzone_values</span><span class="p">))</span>
        <span class="n">dimensions_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;CI&#39;</span><span class="p">,</span> <span class="s1">&#39;CIE&#39;</span><span class="p">):</span>
            <span class="n">dimensions_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;X_Czone&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_Czone&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;X_CIzone&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_CIzone&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CIE&#39;</span><span class="p">:</span>
            <span class="n">dimensions_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;dimensions attribute must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">))</span>
        <span class="n">projection_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;reference_dX&#39;</span><span class="p">,</span> <span class="s1">&#39;reference_dY&#39;</span><span class="p">,</span> <span class="s1">&#39;rotation&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">projection_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;projection attribute must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">projection_keys</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_getoffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the offset to use for this position.</span>
<span class="sd">        Replaces the method defined in D3RectangularGridGeometry to deal with</span>
<span class="sd">        1D or 2D simulations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">D3AcademicGeometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">offset</span>

<div class="viewcode-block" id="D3AcademicGeometry.getcenter"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.getcenter">[docs]</a>    <span class="k">def</span> <span class="nf">getcenter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinate of the grid center as a tuple</span>
<span class="sd">        (center_lon, center_lat).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.ij2xy"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.ij2xy">[docs]</a>    <span class="k">def</span> <span class="nf">ij2xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (x, y) coordinates of point *(i,j)*, in the projection.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param position: position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the C+I domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">oi</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">],</span>
                <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">oj</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.xy2ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.xy2ij">[docs]</a>    <span class="k">def</span> <span class="nf">xy2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (i, j) indexes of point *(x, y)*,</span>
<span class="sd">        in the 2D matrix of gridpoints.</span>

<span class="sd">        :param x: X coordinate of point in the academic projection</span>
<span class="sd">        :param y: Y coordinate of point in the academic projection</span>
<span class="sd">        :param position: position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Caution: (*i,j*) are float (the nearest grid point is the nearest</span>
<span class="sd">        integer).</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the C+I</span>
<span class="sd">        domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">oi</span><span class="p">,</span>
                <span class="n">y</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">oj</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.ij2ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.ij2ll">[docs]</a>    <span class="k">def</span> <span class="nf">ij2ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (lon, lat) coordinates of point *(i,j)*, in degrees.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        This routine has a special meaning for this geometry. It returns the (i, j)</span>
<span class="sd">        position in the original grid (especially after a section extraction) with</span>
<span class="sd">        an offset of one (for old tools compatibility).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2ll</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="p">))</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.ll2ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.ll2ij">[docs]</a>    <span class="k">def</span> <span class="nf">ll2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (i, j) indexes of point *(lon, lat)* in degrees,</span>
<span class="sd">        in the 2D matrix of gridpoints.</span>

<span class="sd">        :param lon: longitude of point in degrees</span>
<span class="sd">        :param lat: latitude of point in degrees</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Caution: the returned (*i,j*) are float.</span>

<span class="sd">        This routine has a special meaning for this geometry. It returns the (lon, lat)</span>
<span class="sd">        position in the original grid (especially after a section extraction) with</span>
<span class="sd">        an offset of one (for old tools compatibility).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2ij</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">),</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.ll2xy"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.ll2xy">[docs]</a>    <span class="k">def</span> <span class="nf">ll2xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (x, y) coordinates of point *(lon, lat)* in degrees.</span>

<span class="sd">        :param lon: longitude of point in degrees</span>
<span class="sd">        :param lat: latitude of point in degrees</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the C+I</span>
<span class="sd">        domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="c1"># TOBECHECKED: position of self.ij2xy(0, 0) inside the formula</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="p">((</span><span class="n">lon</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_dX&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;center&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">(</span><span class="n">lat</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_dY&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;center&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_axis</span><span class="p">(</span><span class="o">*</span><span class="n">xy</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;ll2xy&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.xy2ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.xy2ll">[docs]</a>    <span class="k">def</span> <span class="nf">xy2ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (lon, lat) coordinates of point *(x, y)* in the 2D matrix</span>
<span class="sd">        of gridpoints*(i,j)*, in degrees.</span>

<span class="sd">        :param x: X coordinate of point in the academic projection</span>
<span class="sd">        :param y: Y coordinate of point in the academic projection</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the C+I</span>
<span class="sd">        domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;xy2ll&#39;</span><span class="p">)</span>
        <span class="c1"># TOBECHECKED: position of self.ij2xy(0, 0) inside the formula</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;center&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_dX&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">],</span>
                <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;center&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_dY&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.distance"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.distance">[docs]</a>    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the distance between two points along a straight line in the</span>
<span class="sd">        geometry.</span>
<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">end2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                          <span class="p">((</span><span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">end2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.linspace"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.linspace">[docs]</a>    <span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns evenly spaced points over the specified interval.</span>
<span class="sd">        Points are lined up in the geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param num: number of points, including point1 and point2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;num&#39; must be at least 2.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">),</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">end2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">)))</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.resolution_ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.resolution_ll">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">**</span><span class="n">__</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the minimum of X and Y resolution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.resolution_ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.resolution_ij">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">**</span><span class="n">__</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the minimum of X and Y resolution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.plane_azimuth"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.plane_azimuth">[docs]</a>    <span class="k">def</span> <span class="nf">plane_azimuth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initial bearing from *end1* to *end2* points in plane local referential</span>
<span class="sd">        geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">))</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.</span> <span class="o">-</span> <span class="mf">180.</span></div>

<div class="viewcode-block" id="D3AcademicGeometry.azimuth"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.azimuth">[docs]</a>    <span class="k">def</span> <span class="nf">azimuth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Same as plane_azimuth in this geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane_azimuth</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_what_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the position of the field.</span>

<span class="sd">        :param out: the output open file-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Kind of Geometry&quot;</span><span class="p">,</span> <span class="s1">&#39;Academic&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;latitude&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Latitude&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;longitude&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Longitude&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_what_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the projection of the field&#39;s grid.</span>

<span class="sd">        :param out: the output open file-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;X resolution of the reference grid&quot;</span><span class="p">,</span>
                        <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_dX&#39;</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Y resolution of the reference grid&quot;</span><span class="p">,</span>
                        <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_dY&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="D3AcademicGeometry.make_section_geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3AcademicGeometry.make_section_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_section_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span>
                              <span class="n">points_number</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a academic V2DGeometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param points_number: defines the total number of horizontal points of the</span>
<span class="sd">          section (including ends). If None, defaults to a number computed from</span>
<span class="sd">          the *ends* and the *resolution*.</span>
<span class="sd">        :param resolution: defines the horizontal resolution to be given to the</span>
<span class="sd">          field. If None, defaults to the horizontal resolution of the field.</span>
<span class="sd">        :param position: defines the position of data in the grid (defaults to &#39;center&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;only one of resolution and &quot;</span> <span class="o">+</span>
                               <span class="s2">&quot; points_number can be given.&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span> <span class="o">+</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">))</span>
            <span class="n">points_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">resolution</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;ends&#39; are too near: pure&quot;</span> <span class="o">+</span>
                                   <span class="s2">&quot; interpolation between two gridpoints.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">points_number</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;points_number&#39; must be at least 2.&quot;</span><span class="p">)</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">/</span> <span class="p">(</span><span class="n">points_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">,</span>
                                   <span class="n">typeoffirstfixedsurface</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
                                   <span class="n">levels</span><span class="o">=</span><span class="p">[])</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">:</span><span class="s1">&#39;CIE&#39;</span><span class="p">,</span>
                <span class="s1">&#39;X_resolution&#39;</span><span class="p">:</span><span class="n">resolution</span><span class="p">,</span>
                <span class="s1">&#39;Y_resolution&#39;</span><span class="p">:</span><span class="n">resolution</span><span class="p">,</span>
                <span class="s1">&#39;input_lat&#39;</span><span class="p">:</span><span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;input_lon&#39;</span><span class="p">:</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;input_position&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
        <span class="k">if</span> <span class="s1">&#39;longitude&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;latitude&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span>
            <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">]</span>

        <span class="n">dimensions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="n">points_number</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                      <span class="s1">&#39;X_Iwidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                      <span class="s1">&#39;X_Czone&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Y_Czone&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                      <span class="s1">&#39;X_CIzone&#39;</span><span class="p">:</span><span class="n">points_number</span><span class="p">,</span> <span class="s1">&#39;Y_CIzone&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                      <span class="s1">&#39;X_CIoffset&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>

        <span class="n">rotation</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;rotation&#39;</span><span class="p">:</span><span class="n">Angle</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="s1">&#39;radians&#39;</span><span class="p">),</span>
                      <span class="s1">&#39;reference_dX&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_dX&#39;</span><span class="p">],</span>
                      <span class="s1">&#39;reference_dY&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_dY&#39;</span><span class="p">]}</span>

        <span class="n">kwargs_geom</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;V2D&#39;</span><span class="p">,</span>
                           <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                           <span class="n">grid</span><span class="o">=</span><span class="n">FPDict</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span>
                           <span class="n">projection</span><span class="o">=</span><span class="n">projection</span><span class="p">,</span>
                           <span class="n">dimensions</span><span class="o">=</span><span class="n">FPDict</span><span class="p">(</span><span class="n">dimensions</span><span class="p">),</span>
                           <span class="n">position_on_horizontal_grid</span><span class="o">=</span><span class="s1">&#39;center&#39;</span> <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">position</span><span class="p">,</span>
                           <span class="n">vcoordinate</span><span class="o">=</span><span class="n">vcoordinate</span>
                           <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">:</span>
            <span class="n">kwargs_geom</span><span class="p">[</span><span class="s1">&#39;geoid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoid</span>
        <span class="k">return</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_geom</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="D3RegLLGeometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry">[docs]</a><span class="k">class</span> <span class="nc">D3RegLLGeometry</span><span class="p">(</span><span class="n">D3RectangularGridGeometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles the geometry for a Regular Lon/Lat 3-Dimensions Field.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_collector</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,)</span>
    <span class="n">_footprint</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">attr</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;regular_lonlat&#39;</span><span class="p">])),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isglobal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: True if geometry is global</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">360.</span> <span class="ow">and</span> \
               <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">180.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">D3RegLLGeometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span>
                                           <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                     <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                     <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                     <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">-</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                     <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">-</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                     <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                     <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">-</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                     <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">-</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                     <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;this &#39;input_position&#39;: &quot;</span> <span class="o">+</span>
                                      <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]))</span>

        <span class="c1"># earth-round grids: wrap TODO:</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ll</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ul&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span>
                   <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">config</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_earthround</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_earthround</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="D3RegLLGeometry.tolerant_equal"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.tolerant_equal">[docs]</a>    <span class="k">def</span> <span class="nf">tolerant_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">epsilon</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="c1"># create copies of inner objects to filter some ghost attributes</span>
            <span class="n">almost_self</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                           <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ghost_attributes</span><span class="p">}</span>
            <span class="n">almost_other</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_ghost_attributes</span><span class="p">}</span>
            <span class="c1"># (the same grid could be defined from different inputs)</span>
            <span class="k">for</span> <span class="n">almost</span> <span class="ow">in</span> <span class="p">(</span><span class="n">almost_self</span><span class="p">,</span> <span class="n">almost_other</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;input_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;input_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;input_position&#39;</span><span class="p">):</span>
                    <span class="n">almost</span><span class="p">[</span><span class="s1">&#39;_attributes&#39;</span><span class="p">][</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">almost_self</span><span class="p">[</span><span class="s1">&#39;_attributes&#39;</span><span class="p">][</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getcenter</span><span class="p">()</span>
            <span class="n">almost_other</span><span class="p">[</span><span class="s1">&#39;_attributes&#39;</span><span class="p">][</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">getcenter</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Comparator</span><span class="o">.</span><span class="n">are_equal</span><span class="p">(</span><span class="n">almost_self</span><span class="p">,</span> <span class="n">almost_other</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.getcenter"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.getcenter">[docs]</a>    <span class="k">def</span> <span class="nf">getcenter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinate of the grid center as a tuple of Angles</span>
<span class="sd">        (center_lon, center_lat).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_consistency_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that the geometry is consistent.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;regular_lonlat&#39;</span><span class="p">:</span>
            <span class="n">grid_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;input_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;input_position&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;X_resolution&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;grid attribute must consist in keys: &quot;</span> <span class="o">+</span>
                                   <span class="nb">str</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">))</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
            <span class="n">dimensions_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;dimensions attribute must consist in keys: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">))</span>

<div class="viewcode-block" id="D3RegLLGeometry.ij2xy"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.ij2xy">[docs]</a>    <span class="k">def</span> <span class="nf">ij2xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (x, y) coordinates of point *(i,j)*, in the projection.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param position: position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the C+I</span>
<span class="sd">        domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

        <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="n">Xpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">Ypoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">Xresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Yresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Xorigin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Yorigin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="c1"># origin of coordinates is the center of domain</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Xpoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">j0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ypoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Xorigin</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">oi</span><span class="p">)</span> <span class="o">*</span> <span class="n">Xresolution</span><span class="p">,</span> <span class="n">_rd</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Yorigin</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">j0</span> <span class="o">+</span> <span class="n">oj</span><span class="p">)</span> <span class="o">*</span> <span class="n">Yresolution</span><span class="p">,</span> <span class="n">_rd</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.xy2ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.xy2ij">[docs]</a>    <span class="k">def</span> <span class="nf">xy2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (i, j) indexes of point *(x, y)*,</span>
<span class="sd">        in the 2D matrix of gridpoints.</span>

<span class="sd">        :param x: X coordinate of point in the projection</span>
<span class="sd">        :param y: Y coordinate of point in the projection</span>
<span class="sd">        :param position: position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Caution: (*i,j*) are float (the nearest grid point is the nearest</span>
<span class="sd">        integer).</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the C+I</span>
<span class="sd">        domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="n">Xpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">Ypoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">Xresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Yresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Xorigin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Yorigin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="c1"># origin of coordinates is the center of domain</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Xpoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">j0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ypoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">Xorigin</span><span class="p">)</span> <span class="o">/</span> <span class="n">Xresolution</span> <span class="o">-</span> <span class="n">oi</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j0</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">Yorigin</span><span class="p">)</span> <span class="o">/</span> <span class="n">Yresolution</span> <span class="o">-</span> <span class="n">oj</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_earthround</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">:</span>
                    <span class="n">ii</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ii</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">ii</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">:</span>
                    <span class="n">ii</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">i</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.ij2ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.ij2ll">[docs]</a>    <span class="k">def</span> <span class="nf">ij2ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (lon, lat) coordinates of point *(i,j)*, in degrees.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.ll2ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.ll2ij">[docs]</a>    <span class="k">def</span> <span class="nf">ll2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (i, j) indexes of point *(lon, lat)* in degrees,</span>
<span class="sd">        in the 2D matrix of gridpoints.</span>

<span class="sd">        :param lon: longitude of point in degrees</span>
<span class="sd">        :param lat: latitude of point in degrees</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Caution: (*i,j*) are float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.ll2xy"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.ll2xy">[docs]</a>    <span class="k">def</span> <span class="nf">ll2xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (x, y) coordinates of point *(lon, lat)* in degrees.</span>

<span class="sd">        :param lon: longitude of point in degrees</span>
<span class="sd">        :param lat: latitude of point in degrees</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the C+I</span>
<span class="sd">        domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.xy2ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.xy2ll">[docs]</a>    <span class="k">def</span> <span class="nf">xy2ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (lon, lat) coordinates of point *(x, y)* in the 2D matrix</span>
<span class="sd">        of gridpoints*(i,j)*, in degrees.</span>

<span class="sd">        :param x: X coordinate of point in the projection</span>
<span class="sd">        :param y: Y coordinate of point in the projection</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the C+I</span>
<span class="sd">        domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">xy2ij</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span></div>


<div class="viewcode-block" id="D3RegLLGeometry.global_shift_center"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.global_shift_center">[docs]</a>    <span class="k">def</span> <span class="nf">global_shift_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">longitude_shift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shifts the center of the geometry by *longitude_shift* (in degrees).</span>
<span class="sd">        *longitude_shift* has to be a multiple of the grid&#39;s resolution in</span>
<span class="sd">        longitude.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ll</span><span class="p">()</span>
        <span class="n">zip_width</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ul&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">))</span>
        <span class="n">zip_minus_resolution</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">zip_width</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                                     <span class="n">_rd</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zip_minus_resolution</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
            <span class="n">as_int</span> <span class="o">=</span> <span class="mf">1e6</span>  <span class="c1"># decimal error</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">((</span><span class="n">longitude_shift</span> <span class="o">*</span> <span class="n">as_int</span><span class="p">)</span> <span class="o">%</span>
                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">as_int</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">config</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">((</span><span class="s2">&quot;*longitude_shift* (</span><span class="si">{}</span><span class="s2">) has to be a multiple&quot;</span> <span class="o">+</span>
                                    <span class="s2">&quot; of the grid&#39;s resolution in longitude (</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="p">)</span><span class="o">.</span>
                                   <span class="nb">format</span><span class="p">(</span><span class="n">longitude_shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">longitude_shift</span><span class="p">,</span>
                                     <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">longitude_shift</span><span class="p">,</span>
                                           <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;unable to shift center if &quot;</span> <span class="o">+</span>
                               <span class="s2">&quot;lon_max - lon_min != X_resolution&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.linspace"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.linspace">[docs]</a>    <span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns evenly spaced points over the specified interval.</span>
<span class="sd">        Points are lined up in the geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param num: number of points, including point1 and point2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;num&#39; must be at least 2.&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">)</span>
        <span class="n">xy_linspace</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">),</span>
                               <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">)))</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xy2ll</span><span class="p">(</span><span class="o">*</span><span class="n">xy</span><span class="p">)</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">xy_linspace</span><span class="p">]</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.distance"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.distance">[docs]</a>    <span class="nd">@_need_pyproj_geod</span>
    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the distance between two points along a straight line in the</span>
<span class="sd">        geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>

<span class="sd">        Warning: requires the :mod:`pyproj` module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plast</span> <span class="o">=</span> <span class="n">end1</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">distance</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">plast</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">plast</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">plast</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">return</span> <span class="n">distance</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.make_zoom_geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.make_zoom_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_zoom_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zoom</span><span class="p">,</span> <span class="n">extra_10th</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new geometry with the points contained in *zoom*.</span>

<span class="sd">        :param zoom: a dict(lonmin=, lonmax=, latmin=, latmax=).</span>
<span class="sd">        :param extra_10th: if True, add 1/10th of the X/Y extension of the zoom</span>
<span class="sd">                           (only usefull for the regular_lonlat grid implementation).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs_zoomgeom</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;structure&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span>
                           <span class="s1">&#39;vcoordinate&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(),</span>
                           <span class="s1">&#39;position_on_horizontal_grid&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">position_on_horizontal_grid</span><span class="p">,</span>
                           <span class="s1">&#39;geoid&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">extra_10th</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmax&#39;</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">-</span>
                  <span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmin&#39;</span><span class="p">],</span> <span class="mf">0.</span><span class="p">))</span> <span class="o">/</span> <span class="mf">10.</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmax&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmin&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="mf">10.</span>
            <span class="n">zoom</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lonmin&#39;</span><span class="p">:</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmin&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span>
                    <span class="s1">&#39;lonmax&#39;</span><span class="p">:</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmax&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span>
                    <span class="s1">&#39;latmin&#39;</span><span class="p">:</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmin&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">dy</span><span class="p">,</span>
                    <span class="s1">&#39;latmax&#39;</span><span class="p">:</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmax&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span><span class="p">}</span>
        <span class="n">imin</span><span class="p">,</span> <span class="n">jmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmin&#39;</span><span class="p">],</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmin&#39;</span><span class="p">])</span>
        <span class="n">imax</span><span class="p">,</span> <span class="n">jmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmax&#39;</span><span class="p">],</span> <span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;latmax&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">imin</span> <span class="o">&gt;</span> <span class="n">imax</span><span class="p">:</span>
            <span class="n">gridmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ll</span><span class="p">()[</span><span class="s1">&#39;ll&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">diff_lonmin</span> <span class="o">=</span> <span class="p">(</span><span class="n">gridmin</span> <span class="o">-</span> <span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">zoom</span><span class="p">[</span><span class="s1">&#39;lonmin&#39;</span><span class="p">],</span>
                                                         <span class="n">gridmin</span><span class="p">))</span>
            <span class="n">Xres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">diff_lonmin</span> <span class="o">//</span> <span class="n">Xres</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Xres</span>
            <span class="n">shifted_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">shifted_self</span><span class="o">.</span><span class="n">global_shift_center</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">shifted_self</span><span class="o">.</span><span class="n">make_zoom_geometry</span><span class="p">(</span><span class="n">zoom</span><span class="p">,</span> <span class="n">extra_10th</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># zoom already includes the extra part</span>
        <span class="k">elif</span> <span class="n">imin</span> <span class="o">==</span> <span class="n">imax</span><span class="p">:</span>  <span class="c1"># means 360deg wide</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">imin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">imin</span><span class="p">)),</span>
                   <span class="mi">0</span><span class="p">)</span>
        <span class="n">imax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">imax</span><span class="p">)),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">jmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">jmin</span><span class="p">)),</span>
                   <span class="mi">0</span><span class="p">)</span>
        <span class="n">jmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">jmax</span><span class="p">)),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="n">imax</span> <span class="o">-</span> <span class="n">imin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                         <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="n">jmax</span> <span class="o">-</span> <span class="n">jmin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>
        <span class="n">lonmin</span><span class="p">,</span> <span class="n">latmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">imin</span><span class="p">,</span> <span class="n">jmin</span><span class="p">)</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">kwargs_zoomgeom</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;input_position&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                   <span class="s1">&#39;input_lon&#39;</span><span class="p">:</span><span class="n">Angle</span><span class="p">(</span><span class="n">lonmin</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                                   <span class="s1">&#39;input_lat&#39;</span><span class="p">:</span><span class="n">Angle</span><span class="p">(</span><span class="n">latmin</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                                   <span class="s1">&#39;X_resolution&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">],</span>
                                   <span class="s1">&#39;Y_resolution&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_zoomgeom</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.resolution_ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.resolution_ll">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local resolution at the nearest point of lon/lat.</span>
<span class="sd">        It&#39;s the distance between this point and its closest neighbour.</span>

<span class="sd">        :param lon: longitude of the point in degrees</span>
<span class="sd">        :param lat: latitude of the point in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ij</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.resolution_ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.resolution_ij">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance to the nearest point of (i,j) point.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">iint</span><span class="p">,</span> <span class="n">jint</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">),</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>
        <span class="n">points_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">iint</span> <span class="o">+</span> <span class="n">oi</span><span class="p">,</span> <span class="n">jint</span> <span class="o">+</span> <span class="n">oj</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">oi</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">oj</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                       <span class="k">if</span> <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">iint</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points_list</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>

<div class="viewcode-block" id="D3RegLLGeometry.plane_azimuth"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3RegLLGeometry.plane_azimuth">[docs]</a>    <span class="k">def</span> <span class="nf">plane_azimuth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initial bearing from *end1* to *end2* points in plane local referential</span>
<span class="sd">        geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">))</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.</span> <span class="o">-</span> <span class="mf">180.</span></div>

    <span class="k">def</span> <span class="nf">_what_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">arpifs_var_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the grid of the field.</span>

<span class="sd">        :param out: the output open file-like object</span>
<span class="sd">        :param arpifs_var_names: if True, prints the equivalent &#39;arpifs&#39; variable</span>
<span class="sd">          names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">()</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ll</span><span class="p">()</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Kind of Geometry&quot;</span><span class="p">,</span> <span class="s1">&#39;Regular Lon/Lat&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (ELONC)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Center Longitude in deg&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (ELATC)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Center Latitude in deg&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (EDELX)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Resolution in X, in deg&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (EDELY)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Resolution in Y, in deg&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (ELX)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Domain width in X, in deg&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                        <span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (ELY)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Domain width in Y, in deg&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                        <span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Max Longitude in deg&quot;</span><span class="p">,</span> <span class="n">lons</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Min Longitude in deg&quot;</span><span class="p">,</span> <span class="n">lons</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Max Latitude in deg&quot;</span><span class="p">,</span> <span class="n">lats</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Min Latitude in deg&quot;</span><span class="p">,</span> <span class="n">lats</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Left corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ll&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Left corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ll&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Right corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Right corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Left corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ul&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Left corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ul&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Right corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Right corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span></div>


<span class="k">class</span> <span class="nc">D3RotLLGeometry</span><span class="p">(</span><span class="n">D3RegLLGeometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles the geometry for a Rotated Lon/Lat 3-Dimensions Field.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_collector</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,)</span>
    <span class="n">_footprint</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">attr</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;rotated_lonlat&#39;</span><span class="p">]))</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">D3RegLLGeometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span>
                                           <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                      <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                      <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                      <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">-</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                      <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">-</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                      <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                      <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">-</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                      <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">-</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_rd</span><span class="p">),</span>
                                      <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;this &#39;input_position&#39;: &quot;</span> <span class="o">+</span>
                                      <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rotation&#39;</span><span class="p">,</span> <span class="n">Angle</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;rotation != Angle(0.)&quot;</span><span class="p">)</span>

        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2ll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_rlon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getcenter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinate of the grid center as a tuple of Angles</span>
<span class="sd">        (center_lon, center_lat) in true lon/lat coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_consistency_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the geometry is consistent.</span>

<span class="sd">        Note:</span>
<span class="sd">        **input_lon** and **input_lat** parameters are supposed to be</span>
<span class="sd">        longitude/latitude of input point in the Rotated Lon/lat referential.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;input_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;input_position&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;X_resolution&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_resolution&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;southern_pole_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;southern_pole_lat&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;rotation&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;grid attribute must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;southern_pole_lon&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;southern_pole_lat&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;rotation&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
        <span class="n">dimensions_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;dimensions attribute must consist in keys: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">ij2xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (x, y) == (rot&#39;lon, rot&#39;lat) coordinates of point *(i,j)*,</span>
<span class="sd">        in the rotated coordinates system.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param position: position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="n">Xpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">Ypoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">Xresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Yresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Xorigin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Yorigin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="c1"># origin of coordinates is the center of domain</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Xpoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">j0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ypoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">Xorigin</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">oi</span><span class="p">)</span> <span class="o">*</span> <span class="n">Xresolution</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Yorigin</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">j0</span> <span class="o">+</span> <span class="n">oj</span><span class="p">)</span> <span class="o">*</span> <span class="n">Yresolution</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xy2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (i, j) indexes of point *(x, y)* == (rot&#39;lon, rot&#39;lat),</span>
<span class="sd">        in the 2D matrix of gridpoints.</span>

<span class="sd">        :param x: rotated lon coordinate of point</span>
<span class="sd">        :param y: rotated lat coordinate of point</span>
<span class="sd">        :param position: position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Caution: (*i,j*) are float (the nearest grid point is the nearest</span>
<span class="sd">        integer).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="n">Xpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
        <span class="n">Ypoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="n">Xresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Yresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Xorigin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="n">Yorigin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="c1"># origin of coordinates is the center of domain</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Xpoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">j0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ypoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">Xorigin</span><span class="p">)</span> <span class="o">/</span> <span class="n">Xresolution</span> <span class="o">-</span> <span class="n">oi</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j0</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">Yorigin</span><span class="p">)</span> <span class="o">/</span> <span class="n">Yresolution</span> <span class="o">-</span> <span class="n">oj</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ij2ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (lon, lat) true coordinates of point *(i,j)*, in degrees.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2ll</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">ll2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (i, j) indexes of point *(lon, lat)* in degrees,</span>
<span class="sd">        in the 2D matrix of gridpoints.</span>

<span class="sd">        :param lon: true longitude of point in degrees</span>
<span class="sd">        :param lat: true latitude of point in degrees</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Caution: (*i,j*) are float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2ij</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">),</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ll2xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (x, y) == (rot&#39;lon, rot&#39;lat) coordinates of</span>
<span class="sd">        point *(lon, lat)* in degrees, in the rotated system.</span>

<span class="sd">        :param lon: true longitude of point in degrees</span>
<span class="sd">        :param lat: true latitude of point in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lonlat_to_rotatedlonlat</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">xy2ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (lon, lat) coordinates of point *(x, y)* == (rot&#39;lon, rot&#39;lat)</span>
<span class="sd">        in the rotated system, in degrees.</span>

<span class="sd">        :param x: rotated lon coordinate of point in the projection</span>
<span class="sd">        :param y: rotated lat coordinate of point in the projection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lonlat_to_rotatedlonlat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_lonlat_to_rotatedlonlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Conversion formula from true lon/lat to rotated lon/lat, or **reverse**.</span>
<span class="sd">        Inspired from https://gis.stackexchange.com/questions/10808/manually-transforming-rotated-lat-lon-to-regular-lat-lon</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;southern_pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;southern_pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
        <span class="c1"># spherical to cartesian</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="c1"># conversion</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">x_new</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span>
                     <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span>
                     <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">y_new</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span>
            <span class="n">z_new</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span>
                     <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span>
                     <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="o">-</span><span class="n">phi</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">theta</span>
            <span class="n">x_new</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span>
                     <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span>
                     <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">y_new</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span>
                     <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span>
                     <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">z_new</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span>
        <span class="c1"># cartesian back to spherical coordinates</span>
        <span class="n">lon_new</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y_new</span><span class="p">,</span> <span class="n">x_new</span><span class="p">))</span>
        <span class="n">lat_new</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">z_new</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lon_new</span><span class="p">,</span> <span class="n">lat_new</span><span class="p">)</span>

    <span class="c1"># TODO: def default_cartopy_CRS(self):</span>

    <span class="k">def</span> <span class="nf">_what_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the grid of the field.</span>

<span class="sd">        :param out: the output open file-like object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">()</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ll</span><span class="p">()</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Kind of Geometry&quot;</span><span class="p">,</span> <span class="s1">&#39;Rotated Lon/Lat&#39;</span><span class="p">)</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Southern Pole Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;southern_pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Southern Pole Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;southern_pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Center Longitude (in rotated referential) in deg&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Center Latitude (in rotated referential) in deg&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_center_rlat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Center Longitude (true) in deg&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Center Latitude (true) in deg&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Resolution in X, in deg&quot;</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Resolution in Y, in deg&quot;</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Domain width in X, in deg&quot;</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                        <span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Domain width in Y, in deg&quot;</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">*</span>
                        <span class="p">(</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Max Longitude in deg&quot;</span><span class="p">,</span> <span class="n">lons</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Min Longitude in deg&quot;</span><span class="p">,</span> <span class="n">lons</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Max Latitude in deg&quot;</span><span class="p">,</span> <span class="n">lats</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Min Latitude in deg&quot;</span><span class="p">,</span> <span class="n">lats</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Left corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ll&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Left corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ll&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Right corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Low-Right corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Left corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ul&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Left corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ul&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Right corner Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Upper-Right corner Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>


<div class="viewcode-block" id="D3ProjectedGeometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry">[docs]</a><span class="k">class</span> <span class="nc">D3ProjectedGeometry</span><span class="p">(</span><span class="n">D3RectangularGridGeometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles the geometry for a Projected 3-Dimensions Field.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_collector</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,)</span>
    <span class="n">_footprint</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">attr</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;lambert&#39;</span><span class="p">,</span> <span class="s1">&#39;mercator&#39;</span><span class="p">,</span> <span class="s1">&#39;polar_stereographic&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;space_view&#39;</span><span class="p">])),</span>
            <span class="n">projection</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">FPDict</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="s2">&quot;Handles projection information.&quot;</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">_ghost_attributes</span> <span class="o">=</span> <span class="n">D3RectangularGridGeometry</span><span class="o">.</span><span class="n">_ghost_attributes</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;_proj&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">secant_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Is the projection secant to the sphere ? (or tangent)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;secant_lat&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span> <span class="ow">or</span>
                <span class="s1">&#39;secant_lat1&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">D3ProjectedGeometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">pyproj</span>

        <span class="k">def</span> <span class="nf">compute_center_proj</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">center</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">center</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># x1, y1: coordinates in non rotated proj of input point</span>
                <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)),</span>
                           <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)))</span>
                <span class="c1"># offset between center and input points is known in rotated proj</span>
                <span class="c1"># dx, dy is the offset in non rotated proj</span>
                <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_axis</span><span class="p">(</span>
                    <span class="nb">round</span><span class="p">((</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">],</span>
                          <span class="n">_rd</span><span class="p">),</span>
                    <span class="nb">round</span><span class="p">((</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_position&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">],</span>
                          <span class="n">_rd</span><span class="p">),</span>
                    <span class="s1">&#39;xy2ll&#39;</span><span class="p">)</span>
                <span class="c1"># xc, yc: coordinates of center point in non rotated proj</span>
                <span class="n">xc</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">dx</span>
                <span class="n">yc</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">dy</span>
                <span class="n">center_lon</span><span class="p">,</span> <span class="n">center_lat</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">center_lon</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">center_lat</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)</span>

        <span class="n">projdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lambert&#39;</span><span class="p">:</span><span class="s1">&#39;lcc&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;mercator&#39;</span><span class="p">:</span><span class="s1">&#39;merc&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;polar_stereographic&#39;</span><span class="p">:</span><span class="s1">&#39;stere&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;space_view&#39;</span><span class="p">:</span><span class="s1">&#39;geos&#39;</span><span class="p">}</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="n">projdict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="c1"># build proj</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span>
            <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">jo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">centerPoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">io</span> <span class="o">+</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span>
                           <span class="n">jo</span> <span class="o">+</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>  <span class="c1"># Coordinates of center point</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
            <span class="n">centerPoint</span> <span class="o">=</span> <span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span>
                           <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>  <span class="c1"># Coordinates of center point</span>
        <span class="c1"># CAUTION: x0, y0 are deeply linked with ij2xy and xy2ij methods:</span>
        <span class="c1"># the origin of the grid is the center of the domain !</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;lambert&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">secant_projection</span><span class="p">:</span>
                <span class="n">lat_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
                <span class="n">lat_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
                <span class="n">m1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat_1</span><span class="p">))</span>
                <span class="n">m2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat_2</span><span class="p">))</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat_1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat_2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_K</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">m2</span><span class="p">))</span> <span class="o">/</span> \
                          <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lat_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
                <span class="n">lat_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_K</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cos_sin&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Proj</span><span class="p">(</span><span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
                            <span class="n">lon_0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                            <span class="n">lat_1</span><span class="o">=</span><span class="n">lat_1</span><span class="p">,</span> <span class="n">lat_2</span><span class="o">=</span><span class="n">lat_2</span><span class="p">,</span>
                            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">)</span>
            <span class="n">compute_center_proj</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">centerPoint</span><span class="p">)</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proj</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Proj</span><span class="p">(</span><span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
                                     <span class="n">lon_0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                                     <span class="n">lat_1</span><span class="o">=</span><span class="n">lat_1</span><span class="p">,</span> <span class="n">lat_2</span><span class="o">=</span><span class="n">lat_2</span><span class="p">,</span>
                                     <span class="n">x_0</span><span class="o">=-</span><span class="n">x0</span><span class="p">,</span> <span class="n">y_0</span><span class="o">=-</span><span class="n">y0</span><span class="p">,</span>
                                     <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;mercator&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">secant_projection</span><span class="p">:</span>
                <span class="n">lat_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lat_ts</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Proj</span><span class="p">(</span><span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
                            <span class="n">lon_0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                            <span class="n">lat_ts</span><span class="o">=</span><span class="n">lat_ts</span><span class="p">,</span>
                            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">)</span>
            <span class="n">compute_center_proj</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">centerPoint</span><span class="p">)</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proj</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Proj</span><span class="p">(</span><span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
                                     <span class="n">lon_0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                                     <span class="n">lat_ts</span><span class="o">=</span><span class="n">lat_ts</span><span class="p">,</span>
                                     <span class="n">x_0</span><span class="o">=-</span><span class="n">x0</span><span class="p">,</span> <span class="n">y_0</span><span class="o">=-</span><span class="n">y0</span><span class="p">,</span>
                                     <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;polar_stereographic&#39;</span><span class="p">:</span>
            <span class="n">lat_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">secant_projection</span><span class="p">:</span>
                <span class="n">lat_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lat_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Proj</span><span class="p">(</span><span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
                            <span class="n">lon_0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                            <span class="n">lat_0</span><span class="o">=</span><span class="n">lat_0</span><span class="p">,</span> <span class="n">lat_ts</span><span class="o">=</span><span class="n">lat_ts</span><span class="p">,</span>
                            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">)</span>
            <span class="n">compute_center_proj</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">centerPoint</span><span class="p">)</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proj</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Proj</span><span class="p">(</span><span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
                                     <span class="n">lon_0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                                     <span class="n">lat_0</span><span class="o">=</span><span class="n">lat_0</span><span class="p">,</span> <span class="n">lat_ts</span><span class="o">=</span><span class="n">lat_ts</span><span class="p">,</span>
                                     <span class="n">x_0</span><span class="o">=-</span><span class="n">x0</span><span class="p">,</span> <span class="n">y_0</span><span class="o">=-</span><span class="n">y0</span><span class="p">,</span>
                                     <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;space_view&#39;</span><span class="p">:</span>
            <span class="n">latSat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;satellite_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="n">lonSat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;satellite_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;satellite_height&#39;</span><span class="p">]</span>  <span class="c1"># Height above ellipsoid</span>
            <span class="k">if</span> <span class="n">latSat</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;Only space views with satellite_lat=0 are allowed&quot;</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Proj</span><span class="p">(</span><span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
                            <span class="n">h</span><span class="o">=</span><span class="n">height</span><span class="p">,</span>
                            <span class="n">lon_0</span><span class="o">=</span><span class="n">lonSat</span><span class="p">,</span>
                            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">)</span>
            <span class="n">compute_center_proj</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">centerPoint</span><span class="p">)</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_proj</span> <span class="o">=</span> <span class="n">pyproj</span><span class="o">.</span><span class="n">Proj</span><span class="p">(</span><span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span>
                                     <span class="n">h</span><span class="o">=</span><span class="n">height</span><span class="p">,</span>
                                     <span class="n">lon_0</span><span class="o">=</span><span class="n">lonSat</span><span class="p">,</span>
                                     <span class="n">x_0</span><span class="o">=-</span><span class="n">x0</span><span class="p">,</span> <span class="n">y_0</span><span class="o">=-</span><span class="n">y0</span><span class="p">,</span>
                                     <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;projection: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="D3ProjectedGeometry.tolerant_equal"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.tolerant_equal">[docs]</a>    <span class="k">def</span> <span class="nf">tolerant_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">epsilon</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="c1"># create copies of inner objects to filter some ghost attributes</span>
            <span class="n">almost_self</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                           <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ghost_attributes</span><span class="p">}</span>
            <span class="n">almost_other</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_ghost_attributes</span><span class="p">}</span>
            <span class="c1"># (the same grid could be defined from different inputs)</span>
            <span class="k">for</span> <span class="n">almost</span> <span class="ow">in</span> <span class="p">(</span><span class="n">almost_self</span><span class="p">,</span> <span class="n">almost_other</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;input_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;input_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;input_position&#39;</span><span class="p">):</span>
                    <span class="n">almost</span><span class="p">[</span><span class="s1">&#39;_attributes&#39;</span><span class="p">][</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">almost_self</span><span class="p">[</span><span class="s1">&#39;_attributes&#39;</span><span class="p">][</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getcenter</span><span class="p">()</span>
            <span class="n">almost_other</span><span class="p">[</span><span class="s1">&#39;_attributes&#39;</span><span class="p">][</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">getcenter</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Comparator</span><span class="o">.</span><span class="n">are_equal</span><span class="p">(</span><span class="n">almost_self</span><span class="p">,</span> <span class="n">almost_other</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">_rotate_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used to rotate x/y coordinates to handle rotated geometries.</span>

<span class="sd">        :param direction:, if evals to &#39;xy2ll&#39;, direction used when converting (x, y) to (lat, lon).</span>
<span class="sd">                           if evals to &#39;ll2xy&#39;, direction used when converting (lat, lon) to (x, y).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;rotation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;rotation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;xy2ll&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">),</span>
                        <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;ll2xy&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">),</span>
                        <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s1">&#39;Wrong direction of rotation.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_consistency_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that the geometry is consistent.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;lambert&#39;</span><span class="p">:</span>
            <span class="n">sets_of_keys</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;reference_lat&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;rotation&#39;</span><span class="p">],</span>
                            <span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;secant_lat1&#39;</span><span class="p">,</span> <span class="s1">&#39;secant_lat2&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;rotation&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;polar_stereographic&#39;</span><span class="p">,</span> <span class="s1">&#39;mercator&#39;</span><span class="p">):</span>
            <span class="n">sets_of_keys</span> <span class="o">=</span> <span class="p">([</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;reference_lat&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;rotation&#39;</span><span class="p">],</span>
                            <span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;reference_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;secant_lat&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;rotation&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;space_view&#39;</span><span class="p">:</span>
            <span class="n">sets_of_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;satellite_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;satellite_lon&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;satellite_height&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;rotation&#39;</span><span class="p">,</span>
                            <span class="s1">&#39;reference_lon&#39;</span><span class="p">]</span>
            <span class="n">sets_of_keys</span> <span class="o">=</span> <span class="p">(</span><span class="n">sets_of_keys</span><span class="p">,</span> <span class="n">sets_of_keys</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;projection: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sets_of_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> \
           <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sets_of_keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># print self.projection.keys()</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;attributes for projection &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
                               <span class="s2">&quot; must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">sets_of_keys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; or &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">sets_of_keys</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;reference_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;rotation&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;secant_lat1&#39;</span><span class="p">,</span> <span class="s1">&#39;secant_lat2&#39;</span><span class="p">,</span> <span class="s1">&#39;secant_lat&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;satellite_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;satellite_lon&#39;</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Angle</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="s1">&#39;degrees&#39;</span><span class="p">)),</span>
                              <span class="n">Angle</span><span class="p">)</span>
        <span class="n">grid_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">,</span> <span class="s1">&#39;X_resolution&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_resolution&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;input_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;input_lat&#39;</span><span class="p">,</span> <span class="s1">&#39;input_position&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;grid attribute must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lon&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;input_lat&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
        <span class="n">LAMzone_values</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;CI&#39;</span><span class="p">,</span> <span class="s1">&#39;CIE&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">LAMzone_values</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;grid[&#39;LAMzone&#39;] must be among &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">LAMzone_values</span><span class="p">))</span>
        <span class="n">dimensions_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;CI&#39;</span><span class="p">,</span> <span class="s1">&#39;CIE&#39;</span><span class="p">):</span>
            <span class="n">dimensions_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;X_Czone&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_Czone&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;X_CIzone&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_CIzone&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;CIE&#39;</span><span class="p">:</span>
            <span class="n">dimensions_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">,</span> <span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;dimensions attribute must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">))</span>
        <span class="c1"># if self.projection[&#39;rotation&#39;].get(&#39;degrees&#39;) != 0.0:</span>
        <span class="c1">#    epylog.warning(&#39;*rotation* != 0. may not have been thoroughly tested...&#39;)  # TOBECHECKED: here and there, ...</span>

<div class="viewcode-block" id="D3ProjectedGeometry.select_subzone"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.select_subzone">[docs]</a>    <span class="k">def</span> <span class="nf">select_subzone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subzone</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If a LAMzone defines the geometry, select only the *subzone* from it</span>
<span class="sd">        and return a new geometry object.</span>

<span class="sd">        :param subzone: among (&#39;C&#39;, &#39;CI&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">subzone</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;CI&#39;</span><span class="p">),</span> \
               <span class="s1">&#39;unknown subzone : &#39;</span> <span class="o">+</span> <span class="n">subzone</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geom_kwargs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span><span class="p">)</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;CI&#39;</span><span class="p">:</span>
                <span class="n">io</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">jo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">centerPoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">io</span> <span class="o">+</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span>
                               <span class="n">jo</span> <span class="o">+</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>  <span class="c1"># Coordinates of center point</span>
                <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subzone</span>
                <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">],</span>
                                             <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">],</span>
                                             <span class="s1">&#39;X_CIzone&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">],</span>
                                             <span class="s1">&#39;Y_CIzone&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">],</span>
                                             <span class="s1">&#39;X_Iwidth&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Iwidth&#39;</span><span class="p">],</span>
                                             <span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Iwidth&#39;</span><span class="p">],</span>
                                             <span class="s1">&#39;X_Czone&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Czone&#39;</span><span class="p">],</span>
                                             <span class="s1">&#39;Y_Czone&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Czone&#39;</span><span class="p">]}</span>
            <span class="k">elif</span> <span class="n">subzone</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                <span class="n">centerPoint</span> <span class="o">=</span> <span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Czone&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span>
                               <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Czone&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>  <span class="c1"># Coordinates of center point</span>
                <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_Czone&#39;</span><span class="p">],</span>
                                             <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_Czone&#39;</span><span class="p">]}</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;input_lon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;input_lat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span>
            <span class="n">geom_kwargs</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="s1">&#39;input_position&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">centerPoint</span>
            <span class="n">new_geom</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">geom_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_geom</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">new_geom</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.getcenter"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.getcenter">[docs]</a>    <span class="k">def</span> <span class="nf">getcenter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinate of the grid center as a tuple of Angles</span>
<span class="sd">        (center_lon, center_lat).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.ij2xy"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.ij2xy">[docs]</a>    <span class="k">def</span> <span class="nf">ij2xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (x, y) coordinates of point *(i,j)*, in the projection.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param position: position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the C+I</span>
<span class="sd">        domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="n">Xresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span>
        <span class="n">Yresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Xpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
            <span class="n">Ypoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Xpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span>
            <span class="n">Ypoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span>
        <span class="n">Xorigin</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">Yorigin</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="c1"># origin of coordinates is the center of CI domain</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">Xpoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">j0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ypoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">Xorigin</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">oi</span><span class="p">)</span> <span class="o">*</span> <span class="n">Xresolution</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Yorigin</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">j0</span> <span class="o">+</span> <span class="n">oj</span><span class="p">)</span> <span class="o">*</span> <span class="n">Yresolution</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.xy2ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.xy2ij">[docs]</a>    <span class="k">def</span> <span class="nf">xy2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (i, j) indexes of point *(x, y)*,</span>
<span class="sd">        in the 2D matrix of gridpoints.</span>

<span class="sd">        :param x: X coordinate of point in the projection</span>
<span class="sd">        :param y: Y coordinate of point in the projection</span>
<span class="sd">        :param position: position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Caution: (*i,j*) are float (the nearest grid point is the nearest</span>
<span class="sd">        integer).</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the C+I</span>
<span class="sd">        domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">Xresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span>
        <span class="n">Yresolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Xpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
            <span class="n">Ypoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Xpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span>
            <span class="n">Ypoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span>
        <span class="n">Xorigin</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">Yorigin</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="c1"># origin of coordinates is the center of CI domain</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;X_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">Xpoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">j0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Y_CIoffset&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">Ypoints</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">Xorigin</span><span class="p">)</span> <span class="o">/</span> <span class="n">Xresolution</span> <span class="o">-</span> <span class="n">oi</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">j0</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">Yorigin</span><span class="p">)</span> <span class="o">/</span> <span class="n">Yresolution</span> <span class="o">-</span> <span class="n">oj</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.ll2xy"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.ll2xy">[docs]</a>    <span class="k">def</span> <span class="nf">ll2xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (x, y) coordinates of point *(lon, lat)* in degrees.</span>

<span class="sd">        :param lon: longitude of point in degrees</span>
<span class="sd">        :param lat: latitude of point in degrees</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the C+I</span>
<span class="sd">        domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proj</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_axis</span><span class="p">(</span><span class="o">*</span><span class="n">xy</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;ll2xy&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.xy2ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.xy2ll">[docs]</a>    <span class="k">def</span> <span class="nf">xy2ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (lon, lat) coordinates of point *(x, y)* in the 2D matrix</span>
<span class="sd">        of gridpoints*(i,j)*, in degrees.</span>

<span class="sd">        :param x: X coordinate of point in the projection</span>
<span class="sd">        :param y: Y coordinate of point in the projection</span>

<span class="sd">        Note that origin of coordinates in projection is the center of the</span>
<span class="sd">        C+I domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;xy2ll&#39;</span><span class="p">)</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proj</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># mask invalid values</span>
        <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="n">ll</span>
        <span class="n">lons_is_scalar</span><span class="p">,</span> <span class="n">lats_is_scalar</span> <span class="o">=</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">lons</span> <span class="o">==</span> <span class="n">config</span><span class="o">.</span><span class="n">pyproj_invalid_values</span><span class="p">,</span>
                                <span class="n">lats</span> <span class="o">==</span> <span class="n">config</span><span class="o">.</span><span class="n">pyproj_invalid_values</span><span class="p">)</span>
        <span class="n">lons</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">lons</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lons_is_scalar</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">lats_is_scalar</span><span class="p">:</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="n">lats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ll</span> <span class="o">=</span> <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ll</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.ij2ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.ij2ll">[docs]</a>    <span class="k">def</span> <span class="nf">ij2ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (lon, lat) coordinates of point *(i,j)*, in degrees.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2ll</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="p">))</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.ll2ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.ll2ij">[docs]</a>    <span class="k">def</span> <span class="nf">ll2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (i, j) indexes of point *(lon, lat)* in degrees,</span>
<span class="sd">        in the 2D matrix of gridpoints.</span>

<span class="sd">        :param lon: longitude of point in degrees</span>
<span class="sd">        :param lat: latitude of point in degrees</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>

<span class="sd">        Caution: (*i,j*) are float.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xy2ij</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">),</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.map_factor"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.map_factor">[docs]</a>    <span class="k">def</span> <span class="nf">map_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the map factor at the given latitude(s) *lat* in degrees.&quot;&quot;&quot;</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;mercator&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">secant_projection</span><span class="p">:</span>
                <span class="n">lat_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lat_0</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat_0</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;polar_stereographic&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">secant_projection</span><span class="p">:</span>
                <span class="n">lat_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lat_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">lat_0</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat_0</span><span class="p">))</span> <span class="o">/</span> \
                <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">lat_0</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;lambert&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">secant_projection</span><span class="p">:</span>
                <span class="n">lat_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lat_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat_0</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="p">)</span> <span class="o">*</span> \
                <span class="p">((</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">lat_0</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat_0</span><span class="p">))</span> <span class="o">/</span>
                 <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">lat_0</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lat</span><span class="p">)))</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">_K</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;projection &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; not implemented.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.map_factor_field"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.map_factor_field">[docs]</a>    <span class="k">def</span> <span class="nf">map_factor_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new field whose data is the map factor over the field.</span>

<span class="sd">        :param position: grid position with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs_vcoord</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;structure&#39;</span><span class="p">:</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;typeoffirstfixedsurface&#39;</span><span class="p">:</span> <span class="mi">255</span><span class="p">,</span>
                         <span class="s1">&#39;position_on_grid&#39;</span><span class="p">:</span> <span class="s1">&#39;__unknown__&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;levels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
        <span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_vcoord</span><span class="p">)</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometrys</span><span class="o">.</span><span class="n">almost_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                              <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;H2D&#39;</span><span class="p">,</span>
                                              <span class="n">vcoordinate</span><span class="o">=</span><span class="n">vcoordinate</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;H2D&#39;</span><span class="p">,</span>
                      <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span>
                      <span class="n">fid</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span><span class="s1">&#39;Map Factor&#39;</span><span class="p">},</span>
                      <span class="n">units</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_factor</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.mesh_area"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.mesh_area">[docs]</a>    <span class="k">def</span> <span class="nf">mesh_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the area of a mesh/gridpoint, given its latitude.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_factor</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.mesh_area_field"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.mesh_area_field">[docs]</a>    <span class="k">def</span> <span class="nf">mesh_area_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new field whose data is the mesh area of gridpoints,</span>
<span class="sd">        i.e. X_resolution x Y_resolution / m^2, where m is the local map factor.</span>

<span class="sd">        :param position: grid position with respect to the model cell.</span>
<span class="sd">                         Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_factor_field</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
        <span class="n">dxdy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span>
        <span class="n">m</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="n">dxdy</span> <span class="o">/</span> <span class="n">m</span><span class="o">.</span><span class="n">data</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">m</span><span class="o">.</span><span class="n">fid</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Mesh Area&#39;</span>
        <span class="n">m</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;m^2&#39;</span>
        <span class="k">return</span> <span class="n">m</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.linspace"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.linspace">[docs]</a>    <span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns evenly spaced points over the specified interval.</span>
<span class="sd">        Points are lined up in the geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param num: number of points, including point1 and point2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;num&#39; must be at least 2.&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">)</span>
        <span class="n">xy_linspace</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">),</span>
                               <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">)))</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xy2ll</span><span class="p">(</span><span class="o">*</span><span class="n">xy</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="n">xy_linspace</span><span class="p">]</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.distance"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.distance">[docs]</a>    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the distance between two points along a straight line in the</span>
<span class="sd">        geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">)</span>
        <span class="c1"># distance on the projected surface</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># map factor computed as the mean over 100 points along the line</span>
        <span class="c1"># between point1 and point2</span>
        <span class="n">mean_map_factor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">map_factor</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">mean_map_factor</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.resolution_ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.resolution_ll">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local resolution at the nearest point of lon/lat.</span>
<span class="sd">        It&#39;s the distance between this point and its closest neighbour.</span>

<span class="sd">        :param lon: longitude of the point in degrees</span>
<span class="sd">        :param lat: latitude of the point in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ij</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.resolution_ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.resolution_ij">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance to the nearest point of (i,j) point.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">iint</span><span class="p">,</span> <span class="n">jint</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">),</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>
        <span class="n">points_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">iint</span> <span class="o">+</span> <span class="n">oi</span><span class="p">,</span> <span class="n">jint</span> <span class="o">+</span> <span class="n">oj</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">oi</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">oj</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                       <span class="k">if</span> <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">iint</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points_list</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.plane_azimuth"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.plane_azimuth">[docs]</a>    <span class="k">def</span> <span class="nf">plane_azimuth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initial bearing from *end1* to *end2* points in plane local referential</span>
<span class="sd">        geometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;rotation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">))</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">+</span> <span class="mf">180.</span><span class="p">)</span> <span class="o">%</span> <span class="mf">360.</span> <span class="o">-</span> <span class="mf">180.</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.make_section_geometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.make_section_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">make_section_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end1</span><span class="p">,</span> <span class="n">end2</span><span class="p">,</span>
                              <span class="n">points_number</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a projected V2DGeometry.</span>

<span class="sd">        :param end1: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param end2: must be a tuple (lon, lat) in degrees.</span>
<span class="sd">        :param points_number: defines the total number of horizontal points of the</span>
<span class="sd">          section (including ends). If None, defaults to a number computed from</span>
<span class="sd">          the *ends* and the *resolution*.</span>
<span class="sd">        :param resolution: defines the horizontal resolution to be given to the</span>
<span class="sd">          field. If None, defaults to the horizontal resolution of the field.</span>
<span class="sd">        :param position: defines the position of data in the grid (defaults to &#39;center&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;only one of resolution and &quot;</span> <span class="o">+</span>
                               <span class="s2">&quot; points_number can be given.&quot;</span><span class="p">)</span>

        <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">)</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="o">*</span><span class="n">end1</span><span class="p">)</span> <span class="o">+</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="o">*</span><span class="n">end2</span><span class="p">))</span>
            <span class="n">points_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">resolution</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;ends&#39; are too near: pure&quot;</span> <span class="o">+</span>
                                   <span class="s2">&quot; interpolation between two gridpoints.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">points_number</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;&#39;points_number&#39; must be at least 2.&quot;</span><span class="p">)</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">/</span> <span class="p">(</span><span class="n">points_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;rotation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radians&#39;</span><span class="p">)</span>
        <span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">,</span>
                                   <span class="n">typeoffirstfixedsurface</span><span class="o">=</span><span class="mi">255</span><span class="p">,</span>
                                   <span class="n">levels</span><span class="o">=</span><span class="p">[])</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;X_resolution&#39;</span><span class="p">:</span><span class="n">resolution</span><span class="p">,</span>
                <span class="s1">&#39;Y_resolution&#39;</span><span class="p">:</span><span class="n">resolution</span><span class="p">,</span>
                <span class="s1">&#39;input_lon&#39;</span><span class="p">:</span><span class="n">Angle</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                <span class="s1">&#39;input_lat&#39;</span><span class="p">:</span><span class="n">Angle</span><span class="p">(</span><span class="n">end1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;degrees&#39;</span><span class="p">),</span>
                <span class="s1">&#39;input_position&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">)</span>
        <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;rotation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Angle</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="s1">&#39;radians&#39;</span><span class="p">)</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;X&#39;</span><span class="p">:</span><span class="n">points_number</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
        <span class="n">kwargs_geom</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;V2D&#39;</span><span class="p">,</span>
                           <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                           <span class="n">grid</span><span class="o">=</span><span class="n">FPDict</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span>
                           <span class="n">dimensions</span><span class="o">=</span><span class="n">FPDict</span><span class="p">(</span><span class="n">dimensions</span><span class="p">),</span>
                           <span class="n">projection</span><span class="o">=</span><span class="n">FPDict</span><span class="p">(</span><span class="n">projection</span><span class="p">),</span>
                           <span class="n">geoid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">,</span>
                           <span class="n">position_on_horizontal_grid</span><span class="o">=</span><span class="s1">&#39;center&#39;</span> <span class="k">if</span> <span class="n">position</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">position</span><span class="p">,</span>
                           <span class="n">vcoordinate</span><span class="o">=</span><span class="n">vcoordinate</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoid</span><span class="p">:</span>
            <span class="n">kwargs_geom</span><span class="p">[</span><span class="s1">&#39;geoid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geoid</span>
        <span class="k">return</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_geom</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.compass_grid"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.compass_grid">[docs]</a>    <span class="k">def</span> <span class="nf">compass_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subzone</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the compass grid, i.e. the angle between Y-axis and North for each</span>
<span class="sd">        gridpoint.</span>

<span class="sd">        :param subzone: optional, among (&#39;C&#39;, &#39;CI&#39;), for LAM grids only, returns</span>
<span class="sd">          the grid resp. for the C or C+I zone off the C+I+E zone. \n</span>
<span class="sd">          Default is no subzone, i.e. the whole field.</span>
<span class="sd">        :param position: position of lonlat grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">subzone</span><span class="o">=</span><span class="n">subzone</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;lambert&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">secant_projection</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="o">+</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;mercator&#39;</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;polar_stereographic&#39;</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cos_sin&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">lons</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span> <span class="o">-</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rotation&#39;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">theta</span></div>

<div class="viewcode-block" id="D3ProjectedGeometry.reproject_wind_on_lonlat"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3ProjectedGeometry.reproject_wind_on_lonlat">[docs]</a>    <span class="k">def</span> <span class="nf">reproject_wind_on_lonlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span>
                                 <span class="n">lon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">map_factor_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reprojects a wind vector (u, v) on the grid onto real</span>
<span class="sd">        axes, i.e. with components on true zonal/meridian axes.</span>

<span class="sd">        :param u: the u == zonal-on-the-grid component of wind</span>
<span class="sd">        :param v: the v == meridian-on-the-grid component of wind</span>
<span class="sd">        :param lon: longitudes of points in degrees, if u/v are not vectors</span>
<span class="sd">          on the whole grid</span>
<span class="sd">        :param lat: latitudes of points in degrees, if u/v are not vectors</span>
<span class="sd">          on the whole grid</span>
<span class="sd">        :param map_factor_correction:, applies a correction of magnitude due</span>
<span class="sd">          to map factor.</span>
<span class="sd">        :param reverse: if True, apply the reverse reprojection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="nb">int</span><span class="p">(</span><span class="n">reverse</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">compass_grid</span><span class="p">()</span>
        <span class="n">costheta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">theta</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.</span><span class="p">)</span>
        <span class="n">sintheta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">theta</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">costheta</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="c1"># whole grid</span>
            <span class="k">if</span> <span class="n">map_factor_correction</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_factor_field</span><span class="p">()</span><span class="o">.</span><span class="n">getdata</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">costheta</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">m</span>
            <span class="n">ru</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">costheta</span> <span class="o">-</span> <span class="n">v</span> <span class="o">*</span> <span class="n">sintheta</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">sintheta</span> <span class="o">+</span> <span class="n">v</span> <span class="o">*</span> <span class="n">costheta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># some points</span>
            <span class="n">ru</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">map_factor_correction</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_factor</span><span class="p">(</span><span class="n">lat</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="mf">1.</span>
                <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">m</span>
                <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">costheta</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">sintheta</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">ru</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span>
                <span class="n">rv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">ru</span><span class="p">,</span> <span class="n">rv</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_what_projection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">arpifs_var_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the projection of the field&#39;s grid.</span>

<span class="sd">        :param out: the output open file-like object</span>
<span class="sd">        :param arpifs_var_names: if True, prints the equivalent &#39;arpifs&#39; variable</span>
<span class="sd">          names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projection</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">projmap</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;regular_lonlat&#39;</span><span class="p">:</span><span class="s1">&#39;Regular Lon/Lat&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;lambert&#39;</span><span class="p">:</span><span class="s1">&#39;Lambert (conformal conic)&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;mercator&#39;</span><span class="p">:</span><span class="s1">&#39;Mercator&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;polar_stereographic&#39;</span><span class="p">:</span><span class="s1">&#39;Polar Stereographic&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;space_view&#39;</span><span class="p">:</span><span class="s1">&#39;Space View&#39;</span><span class="p">}</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Kind of projection&quot;</span><span class="p">,</span>
                        <span class="n">projmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;space_view&#39;</span><span class="p">:</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Satellite Longitude in deg&quot;</span><span class="p">,</span>
                            <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;satellite_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Satellite Latitude in deg&quot;</span><span class="p">,</span>
                            <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;satellite_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Reference Longitude in deg&quot;</span><span class="p">,</span>
                            <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">secant_projection</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;lambert&#39;</span><span class="p">:</span>
                    <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Secant Latitude 1 in deg&quot;</span><span class="p">,</span>
                                    <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
                    <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Secant Latitude 2 in deg&quot;</span><span class="p">,</span>
                                    <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat2&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Secant Latitude in deg&quot;</span><span class="p">,</span>
                                    <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;secant_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Sinus of Reference Latitude&quot;</span><span class="p">,</span>
                                <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cos_sin&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                    <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (ELAT0)&#39;</span>
                <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Reference Latitude in deg&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                                <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
                <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (ELON0)&#39;</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Reference Longitude in deg&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                            <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;reference_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Angle of rotation in deg&quot;</span><span class="p">,</span> <span class="n">projection</span><span class="p">[</span><span class="s1">&#39;rotation&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">()</span>
            <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ll</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">subzone</span><span class="o">=</span><span class="s1">&#39;CI&#39;</span><span class="p">)</span>
            <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gimme_corners_ll</span><span class="p">(</span><span class="n">subzone</span><span class="o">=</span><span class="s1">&#39;CI&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (ELONC)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Center Longitude (of C+I) in deg&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_center_lon</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (ELATC)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Center Latitude (of C+I) in deg&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_center_lat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (EDELX)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Resolution in X, in metres&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (EDELY)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Resolution in Y, in metres&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;LAMzone&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimX</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span>
            <span class="n">dimY</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimX</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X_CIzone&#39;</span><span class="p">]</span>
            <span class="n">dimY</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y_CIzone&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (ELX)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                        <span class="s2">&quot;Domain width (of C+I) in X, in metres&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X_resolution&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">dimX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">arpifs_var_names</span><span class="p">:</span>
            <span class="n">varname</span> <span class="o">=</span> <span class="s1">&#39; (ELY)&#39;</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                        <span class="s2">&quot;Domain width (of C+I) in Y, in metres&quot;</span> <span class="o">+</span> <span class="n">varname</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y_resolution&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">dimY</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Max Longitude (of C+I) in deg&quot;</span><span class="p">,</span> <span class="n">lons</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Min Longitude (of C+I) in deg&quot;</span><span class="p">,</span> <span class="n">lons</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Max Latitude (of C+I) in deg&quot;</span><span class="p">,</span> <span class="n">lats</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Min Latitude (of C+I) in deg&quot;</span><span class="p">,</span> <span class="n">lats</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                        <span class="s2">&quot;Low-Left corner (of C+I) Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ll&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                        <span class="s2">&quot;Low-Left corner (of C+I) Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ll&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                        <span class="s2">&quot;Low-Right corner (of C+I) Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                        <span class="s2">&quot;Low-Right corner (of C+I) Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;lr&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                        <span class="s2">&quot;Upper-Left corner (of C+I) Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ul&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                        <span class="s2">&quot;Upper-Left corner (of C+I) Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ul&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                        <span class="s2">&quot;Upper-Right corner (of C+I) Longitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span>
                        <span class="s2">&quot;Upper-Right corner (of C+I) Latitude in deg&quot;</span><span class="p">,</span>
                        <span class="n">corners</span><span class="p">[</span><span class="s1">&#39;ur&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># FIXME: cleanme def __eq__(self, other):</span>
    <span class="c1">#    &quot;&quot;&quot;Test of equality by recursion on the object&#39;s attributes.&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;    if self.__class__ == other.__class__ and \</span>
<span class="sd">           set(self._attributes.keys()) == set(other._attributes.keys()):</span>
<span class="sd">            for attr in self._attributes.keys():</span>
<span class="sd">                if attr == &#39;grid&#39;:</span>
<span class="sd">                    # the same grid could be defined from different inputs</span>
<span class="sd">                    selfgrid = {k:v for k, v in self.grid.items() if</span>
<span class="sd">                                k not in [&#39;input_lon&#39;,</span>
<span class="sd">                                          &#39;input_lat&#39;,</span>
<span class="sd">                                          &#39;input_position&#39;]}</span>
<span class="sd">                    othergrid = {k:v for k, v in self.grid.items() if</span>
<span class="sd">                                 k not in [&#39;input_lon&#39;,</span>
<span class="sd">                                           &#39;input_lat&#39;,</span>
<span class="sd">                                           &#39;input_position&#39;]}</span>
<span class="sd">                    ok = (selfgrid == othergrid and</span>
<span class="sd">                          self.getcenter() == other.getcenter())</span>
<span class="sd">                else:</span>
<span class="sd">                    ok = self._attributes[attr] == other._attributes[attr]</span>
<span class="sd">                if not ok:</span>
<span class="sd">                    break</span>
<span class="sd">        else:</span>
<span class="sd">            ok = False</span>
<span class="sd">        return ok</span>

<span class="sd">    def __hash__(self):</span>
<span class="sd">        # known issue __eq__/__hash__ must be defined both or none, else inheritance is broken</span>
<span class="sd">        return super(D3ProjectedGeometry, self).__hash__()&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="D3GaussGeometry"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry">[docs]</a><span class="k">class</span> <span class="nc">D3GaussGeometry</span><span class="p">(</span><span class="n">D3Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handles the geometry for a Global Gauss grid 3-Dimensions Field.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_collector</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,)</span>
    <span class="n">_footprint</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">attr</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">values</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">,</span> <span class="s1">&#39;reduced_gauss&#39;</span><span class="p">,</span> <span class="s1">&#39;regular_gauss&#39;</span><span class="p">])),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">_ghost_attributes</span> <span class="o">=</span> <span class="n">D3Geometry</span><span class="o">.</span><span class="n">_ghost_attributes</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;_buffered_gauss_grid&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">isglobal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: True if geometry is global</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_consistency_check</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that the geometry is consistent.&quot;&quot;&quot;</span>
        <span class="n">grid_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">,</span> <span class="s1">&#39;latitudes&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">:</span>
            <span class="n">grid_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">,</span> <span class="s1">&#39;pole_lat&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;grid attribute must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">grid_keys</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">Angle</span><span class="p">),</span> \
            <span class="s2">&quot;&#39;latitudes&#39; attribute of grid must be a list of Angle objects.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">],</span> <span class="n">Angle</span><span class="p">)</span>
        <span class="n">dimensions_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;max_lon_number&#39;</span><span class="p">,</span> <span class="s1">&#39;lat_number&#39;</span><span class="p">,</span> <span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;dimensions attribute must consist in keys: &quot;</span> <span class="o">+</span>
                               <span class="nb">str</span><span class="p">(</span><span class="n">dimensions_keys</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_reduced_gauss&#39;</span> \
           <span class="ow">and</span> <span class="n">nearlyEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span> <span class="mf">0.</span><span class="p">)</span> \
           <span class="ow">and</span> <span class="n">nearlyEqual</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">),</span> <span class="mf">90.</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attributes</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;reduced_gauss&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="D3GaussGeometry.ij2ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.ij2ll">[docs]</a>    <span class="k">def</span> <span class="nf">ij2ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (lon, lat) coordinates of point *(i,j)*, in degrees.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;horizontal staggered grids for reduced</span><span class="se">\</span>
<span class="s2">                                       gauss grid are not implemented.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span>\
           <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">latitudes</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">]))])</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">latitudes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">/</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

        <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_stretch</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3GaussGeometry.ll2ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.ll2ij">[docs]</a>    <span class="k">def</span> <span class="nf">ll2ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the (*i, j*) coordinates in the 2D matrix of gridpoints,</span>
<span class="sd">        of the gridpoint nearest to (*lon*, *lat*).</span>

<span class="sd">        :param lon: longitude of point in degrees</span>
<span class="sd">        :param lat: latitude of point in degrees</span>
<span class="sd">        :param position: lat lon position to return with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">ij</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nearest_points</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">},</span> <span class="n">position</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ij</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ij</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_allocate_colocation_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compressed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_float</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the array for lonlat grid.</span>
<span class="sd">        Just a trick to avoid recomputing the array for several fields that</span>
<span class="sd">        share their geometry.</span>

<span class="sd">        :param compressed: if True, return 1D arrays, else 2D masked arrays.</span>
<span class="sd">        :param as_float: if True, return arrays with dtype float64, else int64.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Jmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]</span>
        <span class="n">Imax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">]</span>
        <span class="n">igrid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">jgrid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Jmax</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Imax</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                <span class="n">igrid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">jgrid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">as_float</span><span class="p">:</span>
            <span class="n">igrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">jgrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jgrid</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">igrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">igrid</span><span class="p">)</span>
            <span class="n">jgrid</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jgrid</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">compressed</span><span class="p">:</span>
            <span class="n">igrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">igrid</span><span class="p">)</span>
            <span class="n">jgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">jgrid</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clear_buffered_gauss_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deletes the buffered lonlat grid if any.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_buffered_gauss_grid&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gridpoints_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of gridpoints of the grid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="D3GaussGeometry.get_lonlat_grid"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.get_lonlat_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_lonlat_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">nb_validities</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="n">force_longitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of two tables containing one the longitude of each</span>
<span class="sd">        point, the other the latitude, with 2D shape.</span>

<span class="sd">        Shape of 2D data in Gauss grids: \n</span>
<span class="sd">          - grid[0, 0:Nj] is first (Northern) band of latitude, masked after</span>
<span class="sd">            Nj = number of longitudes for latitude j \n</span>
<span class="sd">          - grid[-1, 0:Nj] is last (Southern) band of latitude (idem).</span>

<span class="sd">        :param position: position of lonlat grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        :param d4: - if True,  returned values are shaped in a 4 dimensions array</span>
<span class="sd">                   - if False, shape of returned values is determined with respect to geometry.</span>
<span class="sd">                      d4=True requires nb_validities &gt; 0</span>
<span class="sd">        :param nb_validities: number of validities represented in data values</span>
<span class="sd">        :param force_longitudes: if &#39;positive&#39;, the longitudes will be forced positive</span>
<span class="sd">                                 if &#39;]-180,180]&#39;, the longitudes will be in the ]-180, 180] interval</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># !!! **_ enables the method to receive arguments specific to</span>
        <span class="c1">#     other geometries but useless here ! Do not remove.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_buffered_gauss_grid&#39;</span><span class="p">)</span> <span class="ow">and</span> \
           <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;filled&#39;</span><span class="p">):</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">]</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allocate_colocation_grid</span><span class="p">(</span><span class="n">compressed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                            <span class="n">as_float</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">igrid</span><span class="p">,</span> <span class="n">jgrid</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
            <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">lats</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">FA_buffered_gauss_grid</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_buffered_gauss_grid&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lons&#39;</span><span class="p">:</span><span class="n">lons</span><span class="p">,</span> <span class="s1">&#39;lats&#39;</span><span class="p">:</span><span class="n">lats</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># trick: the arrays remain pointers to where they were</span>
                    <span class="c1"># created, so that they can be shared by several geometry</span>
                    <span class="c1"># objects or fields !</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lons&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">lats</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;lats&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">lons</span><span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_buffered_gauss_grid</span><span class="p">[</span><span class="s1">&#39;filled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">d4</span><span class="p">:</span>
            <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reshape_lonlat_4d</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">nb_validities</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">d4</span> <span class="ow">and</span> <span class="n">nb_validities</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;*nb_validities* must be 0 when d4==False&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">force_longitudes</span> <span class="o">==</span> <span class="s1">&#39;positive&#39;</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">positive_longitudes</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">force_longitudes</span> <span class="o">==</span> <span class="s1">&#39;]-180,180]&#39;</span><span class="p">:</span>
            <span class="n">lons</span> <span class="o">=</span> <span class="n">longitudes_between_minus180_180</span><span class="p">(</span><span class="n">lons</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3GaussGeometry.get_datashape"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.get_datashape">[docs]</a>    <span class="k">def</span> <span class="nf">get_datashape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_dimZ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the data shape according to the geometry.</span>

<span class="sd">        :param force_dimZ: if supplied, force the Z dimension instead of that</span>
<span class="sd">          of the vertical geometry</span>
<span class="sd">        :param dimT: if supplied, is the time dimension to be added to the</span>
<span class="sd">          data shape</span>
<span class="sd">        :param d4: - if True,  shape is 4D (need to specify *dimT*)</span>
<span class="sd">                   - if False, shape is 3D if dimZ &gt; 1 else 2D</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dimY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]</span>
        <span class="n">dimX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;max_lon_number&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">force_dimZ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimZ</span> <span class="o">=</span> <span class="n">force_dimZ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dimZ</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d4</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">dimT</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> \
                <span class="s2">&quot;*dimT* must be supplied with *d4*=True&quot;</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimT</span><span class="p">,</span> <span class="n">dimZ</span><span class="p">,</span> <span class="n">dimY</span><span class="p">,</span> <span class="n">dimX</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datashape</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">dimZ</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimZ</span><span class="p">)</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimY</span><span class="p">)</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dimX</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3GaussGeometry.reshape_data"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.reshape_data">[docs]</a>    <span class="k">def</span> <span class="nf">reshape_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">first_dimension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d4</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 2D data (horizontal dimensions) reshaped from 1D,</span>
<span class="sd">        according to geometry.</span>

<span class="sd">        :param data: the 1D data (or 3D with a T and Z dimensions,</span>
<span class="sd">          or 2D with either a T/Z dimension, to be specified),</span>
<span class="sd">          of dimension concording with geometry. In case data is 3D, T must be</span>
<span class="sd">          first dimension and Z the second.</span>
<span class="sd">        :param first_dimension: in case data is 2D, specify what is the first</span>
<span class="sd">          dimension of data among (&#39;T&#39;, &#39;Z&#39;)</span>
<span class="sd">        :param d4: - if True,  returned values are shaped in a 4 dimensions array</span>
<span class="sd">                   - if False, shape of returned values is determined with respect to geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span>
        <span class="n">shp_in</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">nb_levels</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">nb_validities</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">first_dimension</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">),</span> \
                <span class="s2">&quot;*first_dimension* must be among (&#39;T&#39;, &#39;Z&#39;) if *data*.shape == 2&quot;</span>
            <span class="k">if</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
                <span class="n">nb_validities</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
                <span class="n">nb_levels</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">nb_validities</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">nb_levels</span> <span class="o">=</span> <span class="n">shp_in</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">nb_levels</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)),</span> \
               <span class="s2">&quot;vertical dimension of data must be 1 or self.vcoordinate.levels=&quot;</span> <span class="o">+</span> \
               <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcoordinate</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="n">shp4D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_datashape</span><span class="p">(</span><span class="n">dimT</span><span class="o">=</span><span class="n">nb_validities</span><span class="p">,</span> <span class="n">force_dimZ</span><span class="o">=</span><span class="n">nb_levels</span><span class="p">,</span> <span class="n">d4</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data4D</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_all</span><span class="p">(</span><span class="n">shp4D</span><span class="p">)</span>
        <span class="n">ind_end</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]):</span>
            <span class="n">ind_begin</span> <span class="o">=</span> <span class="n">ind_end</span>
            <span class="n">ind_end</span> <span class="o">=</span> <span class="n">ind_begin</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">buff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">ind_begin</span><span class="p">,</span> <span class="n">ind_end</span><span class="p">)]</span>
                <span class="n">data4D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">])]</span> <span class="o">=</span> <span class="n">buff</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">buff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ind_begin</span><span class="p">,</span> <span class="n">ind_end</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">nb_levels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">data4D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">])]</span> <span class="o">=</span> <span class="n">buff</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data4D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">])]</span> <span class="o">=</span> <span class="n">buff</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">buff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ind_begin</span><span class="p">,</span> <span class="n">ind_end</span><span class="p">)]</span>
                <span class="n">data4D</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">])]</span> <span class="o">=</span> <span class="n">buff</span>
        <span class="k">if</span> <span class="n">ind_end</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;data have a wrong length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d4</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">data_out</span> <span class="o">=</span> <span class="n">data4D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">data_out</span> <span class="o">=</span> <span class="n">data4D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp_in</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
                    <span class="n">data_out</span> <span class="o">=</span> <span class="n">data4D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="k">elif</span> <span class="n">first_dimension</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
                    <span class="n">data_out</span> <span class="o">=</span> <span class="n">data4D</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">data_out</span></div>

<div class="viewcode-block" id="D3GaussGeometry.fill_maskedvalues"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.fill_maskedvalues">[docs]</a>    <span class="k">def</span> <span class="nf">fill_maskedvalues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of *data* with &#39;real&#39; masked values (i.e. not those</span>
<span class="sd">        linked to reduced Gauss) filled with *fill_value*.</span>
<span class="sd">        *data* must be already 4D for simplicity reasons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
        <span class="n">data_filled</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data_filled</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]):</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i0</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">data_filled</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="n">data_filled</span></div>

<div class="viewcode-block" id="D3GaussGeometry.horizontally_flattened"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.horizontally_flattened">[docs]</a>    <span class="k">def</span> <span class="nf">horizontally_flattened</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of *data* with horizontal dimensions flattened and</span>
<span class="sd">        compressed (cf. numpy.ma.masked_array.compressed).</span>
<span class="sd">        *data* must be 4D for simplicity reasons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">)</span>
        <span class="n">data3D</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gridpoints_number</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">data3D</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data3D</span></div>

<div class="viewcode-block" id="D3GaussGeometry.resolution_ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.resolution_ll">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average meridian resolution (worst directional resolution)</span>
<span class="sd">        at point position.</span>

<span class="sd">        :param lon: longitude of the point in degrees</span>
<span class="sd">        :param lat: latitude of the point in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_j</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="D3GaussGeometry.meridian_resolution_j"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.meridian_resolution_j">[docs]</a>    <span class="k">def</span> <span class="nf">meridian_resolution_j</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average meridian resolution at longitude circle number *j*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="n">jm1</span> <span class="o">=</span> <span class="n">jint</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">jp1</span> <span class="o">=</span> <span class="n">jint</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">jm1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jp1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">jp1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jm1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jp1</span><span class="p">))</span> <span class="o">+</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jm1</span><span class="p">)))</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="k">return</span> <span class="n">dist</span></div>

<div class="viewcode-block" id="D3GaussGeometry.zonal_resolution_j"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.zonal_resolution_j">[docs]</a>    <span class="k">def</span> <span class="nf">zonal_resolution_j</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average zonal resolution at longitude circle number j.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jint</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">jint</span><span class="p">))</span></div>

<div class="viewcode-block" id="D3GaussGeometry.resolution_field_from_stretching"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.resolution_field_from_stretching">[docs]</a>    <span class="nd">@_need_pyproj_geod</span>
    <span class="k">def</span> <span class="nf">resolution_field_from_stretching</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a field which values are the local resolution computed as the</span>
<span class="sd">        nominal resolution stretched locally by the map factor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">sphere</span><span class="p">,</span> <span class="s2">&quot;Method is not available with a non-spheroid geoid.&quot;</span>
        <span class="n">zonal_equatorial_resolution</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyproj_geod</span><span class="o">.</span><span class="n">a</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;max_lon_number&#39;</span><span class="p">]</span>
        <span class="n">mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_factor_field</span><span class="p">()</span>
        <span class="n">mf</span><span class="o">.</span><span class="n">fid</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;resolution_from_stretching&#39;</span>
        <span class="n">mf</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="n">zonal_equatorial_resolution</span> <span class="o">/</span> <span class="n">mf</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mf</span></div>

<div class="viewcode-block" id="D3GaussGeometry.resolution_j"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.resolution_j">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_j</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average meridian resolution at longitude circle number j.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">meridian_resolution_j</span><span class="p">(</span><span class="n">j</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3GaussGeometry.resolution_field"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.resolution_field">[docs]</a>    <span class="k">def</span> <span class="nf">resolution_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;meridian&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a field whose values are the local resolution in m.</span>

<span class="sd">        :param direction: among (&#39;zonal&#39;, &#39;meridian&#39;), direction in which</span>
<span class="sd">                          the resolution is computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;zonal&#39;</span><span class="p">,</span> <span class="s1">&#39;meridian&#39;</span><span class="p">)</span>
        <span class="n">resolutions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span> <span class="o">+</span> <span class="s1">&#39;_resolution_j&#39;</span><span class="p">)(</span><span class="n">j</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">])]</span>
        <span class="n">resol_2d</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">resolutions</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">resol_2d</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;H2D&#39;</span><span class="p">,</span>
                      <span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">fid</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span><span class="n">direction</span> <span class="o">+</span> <span class="s1">&#39; resolution&#39;</span><span class="p">},</span>
                      <span class="n">units</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="n">resol_2d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span></div>

<div class="viewcode-block" id="D3GaussGeometry.distance_to_nearest_neighbour_ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.distance_to_nearest_neighbour_ll">[docs]</a>    <span class="k">def</span> <span class="nf">distance_to_nearest_neighbour_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the local resolution at the nearest point of lon/lat.</span>
<span class="sd">        It&#39;s the distance between this point and its closest neighbour.</span>

<span class="sd">        :param lon: longitude of the point in degrees</span>
<span class="sd">        :param lat: latitude of the point in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_to_nearest_neighbour_ij</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2ij</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">))</span></div>

<div class="viewcode-block" id="D3GaussGeometry.distance_to_nearest_neighbour_ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.distance_to_nearest_neighbour_ij">[docs]</a>    <span class="k">def</span> <span class="nf">distance_to_nearest_neighbour_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance to the nearest point of (i,j) point</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME: not sure this is exactly computed</span>
        <span class="p">(</span><span class="n">iint</span><span class="p">,</span> <span class="n">jint</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">),</span>
                        <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>
        <span class="n">points_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">oi</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">oj</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">oj</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">oj</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">pi</span> <span class="o">=</span> <span class="n">iint</span> <span class="o">+</span> <span class="n">oi</span>
                    <span class="n">pj</span> <span class="o">=</span> <span class="n">jint</span> <span class="o">+</span> <span class="n">oj</span>
                    <span class="k">if</span> <span class="n">pj</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">pj</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">pi</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">][</span><span class="n">pj</span><span class="p">]</span>
                        <span class="n">points_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pi</span><span class="p">,</span> <span class="n">pj</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">iint</span><span class="p">,</span> <span class="n">jint</span><span class="p">),</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points_list</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>

<div class="viewcode-block" id="D3GaussGeometry.point_is_inside_domain_ll"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.point_is_inside_domain_ll">[docs]</a>    <span class="k">def</span> <span class="nf">point_is_inside_domain_ll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">**</span><span class="n">__</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the point(s) of lon/lat coordinates is(are) inside the</span>
<span class="sd">        field.</span>
<span class="sd">        This is always the case in Gauss grids, no real meaning.</span>

<span class="sd">        :param lon: longitude of the point in degrees</span>
<span class="sd">        :param lat: latitude of the point in degrees</span>
<span class="sd">        :param margin: considers the point inside if at least &#39;margin&#39; points far</span>
<span class="sd">          from the border. The -0.1 default is a safety for precision errors.</span>
<span class="sd">        :param position: position of the grid with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3GaussGeometry.point_is_inside_domain_ij"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.point_is_inside_domain_ij">[docs]</a>    <span class="k">def</span> <span class="nf">point_is_inside_domain_ij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">margin</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the point(s) of lon/lat coordinates is(are) inside the</span>
<span class="sd">        field.</span>

<span class="sd">        :param i: X index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param j: Y index of point in the 2D matrix of gridpoints</span>
<span class="sd">        :param margin: DEPRECATED</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="n">i</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="n">j</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])</span>
        <span class="c1"># Firstly we test the validity of j.</span>
        <span class="c1"># In case j is invalid result will be False</span>
        <span class="c1"># but we need a valid value for j to test the i validity</span>
        <span class="n">j2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>
                                                     <span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">]),</span>
                                   <span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>
                                                     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dimensions</span><span class="p">[</span><span class="n">j2</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">inside</span></div>

    <span class="k">def</span> <span class="nf">_rotate_stretch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method used to transform true lon/lat into</span>
<span class="sd">        rotated and stretched lon/lat.</span>

<span class="sd">        :param lon: longitude in degrees</span>
<span class="sd">        :param lat: latitude in degrees</span>
<span class="sd">        :param reverse: if True, do the reverse transform.</span>

<span class="sd">        Computation adapted from arpifs/transform/trareca.F90 and tracare.F90.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">:</span>
            <span class="n">KTYP</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">KTYP</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">PFACDI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">]</span>
        <span class="n">ZDBLC</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">PFACDI</span>
        <span class="n">ZC2P1</span> <span class="o">=</span> <span class="n">PFACDI</span> <span class="o">*</span> <span class="n">PFACDI</span> <span class="o">+</span> <span class="mf">1.</span>
        <span class="n">ZC2M1</span> <span class="o">=</span> <span class="n">PFACDI</span> <span class="o">*</span> <span class="n">PFACDI</span> <span class="o">-</span> <span class="mf">1.</span>
        <span class="n">ZCRAP</span> <span class="o">=</span> <span class="o">-</span><span class="n">ZC2M1</span> <span class="o">/</span> <span class="n">ZC2P1</span>
        <span class="n">ZEPS</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">epsilon</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;rotated&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">lon0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lon0</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">degrees_nearest_mod</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lon0</span><span class="p">)</span>
            <span class="n">PSLAR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span>
            <span class="n">PSLOR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
            <span class="n">PCLOR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">KTYP</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Complete ARPEGE</span>
                <span class="p">(</span><span class="n">PCLAP</span><span class="p">,</span> <span class="n">PSLAP</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cos_sin&#39;</span><span class="p">)</span>
                <span class="p">(</span><span class="n">PCLOP</span><span class="p">,</span> <span class="n">PSLOP</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cos_sin&#39;</span><span class="p">)</span>
                <span class="n">ZCLAR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">PSLAR</span> <span class="o">*</span> <span class="n">PSLAR</span><span class="p">)</span>
                <span class="n">ZA</span> <span class="o">=</span> <span class="n">PSLAP</span> <span class="o">*</span> <span class="n">PSLAR</span> <span class="o">+</span> <span class="n">PCLAP</span> <span class="o">*</span> <span class="n">ZCLAR</span> <span class="o">*</span> \
                     <span class="p">(</span><span class="n">PCLOP</span> <span class="o">*</span> <span class="n">PCLOR</span> <span class="o">+</span> <span class="n">PSLOP</span> <span class="o">*</span> <span class="n">PSLOR</span><span class="p">)</span>
                <span class="n">PSLAC</span> <span class="o">=</span> <span class="p">(</span><span class="n">ZCRAP</span> <span class="o">+</span> <span class="n">ZA</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">ZA</span> <span class="o">*</span> <span class="n">ZCRAP</span><span class="p">)</span>
                <span class="n">ZB</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ZEPS</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">ZA</span> <span class="o">*</span> <span class="n">ZA</span><span class="p">))</span>
                <span class="n">PCLOC</span> <span class="o">=</span> <span class="p">(</span><span class="n">PCLAP</span> <span class="o">*</span> <span class="n">PSLAR</span> <span class="o">-</span> <span class="n">PSLAP</span> <span class="o">*</span> <span class="n">ZCLAR</span> <span class="o">*</span>
                         <span class="p">(</span><span class="n">PCLOP</span> <span class="o">*</span> <span class="n">PCLOR</span> <span class="o">+</span> <span class="n">PSLOP</span> <span class="o">*</span> <span class="n">PSLOR</span><span class="p">))</span> <span class="o">*</span> <span class="n">ZB</span>
                <span class="n">PSLOC</span> <span class="o">=</span> <span class="n">ZCLAR</span> <span class="o">*</span> <span class="p">(</span><span class="n">PSLOP</span> <span class="o">*</span> <span class="n">PCLOR</span> <span class="o">-</span> <span class="n">PCLOP</span> <span class="o">*</span> <span class="n">PSLOR</span><span class="p">)</span> <span class="o">*</span> <span class="n">ZB</span>
                <span class="n">PSLAC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLAC</span><span class="p">))</span>
                <span class="n">PCLOC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PCLOC</span><span class="p">))</span>
                <span class="n">PSLOC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLOC</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">PSLOC</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">PSLOC</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">PCLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">PCLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">PSLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">PSLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
                            <span class="n">PSLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                            <span class="n">PCLOC</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">PCLOC</span> <span class="o">*</span> <span class="n">PCLOC</span> <span class="o">+</span> <span class="n">PSLOC</span> <span class="o">*</span> <span class="n">PSLOC</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
                        <span class="n">PSLOC</span> <span class="o">=</span> <span class="mf">1.</span>
                        <span class="n">PCLOC</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Schmidt</span>
                <span class="n">PSLOC</span> <span class="o">=</span> <span class="n">PSLOR</span>
                <span class="n">PCLOC</span> <span class="o">=</span> <span class="n">PCLOR</span>
                <span class="n">PSLAC</span> <span class="o">=</span> <span class="p">(</span><span class="n">ZC2P1</span> <span class="o">*</span> <span class="n">PSLAR</span> <span class="o">-</span> <span class="n">ZC2M1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ZC2P1</span> <span class="o">-</span> <span class="n">ZC2M1</span> <span class="o">*</span> <span class="n">PSLAR</span><span class="p">)</span>
                <span class="n">PSLAC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLAC</span><span class="p">))</span>

            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">PSLAC</span><span class="p">)</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">PSLOC</span><span class="p">,</span> <span class="n">PCLOC</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">PSLAC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lat</span><span class="p">))</span>
            <span class="n">PCLOC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
            <span class="n">PSLOC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lon</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">KTYP</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Complete ARPEGE</span>
                <span class="p">(</span><span class="n">PCLAP</span><span class="p">,</span> <span class="n">PSLAP</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cos_sin&#39;</span><span class="p">)</span>
                <span class="p">(</span><span class="n">PCLOP</span><span class="p">,</span> <span class="n">PSLOP</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cos_sin&#39;</span><span class="p">)</span>
                <span class="n">ZCLAC</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">PSLAC</span> <span class="o">*</span> <span class="n">PSLAC</span><span class="p">)</span>
                <span class="n">ZA</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">ZC2P1</span> <span class="o">+</span> <span class="n">ZC2M1</span> <span class="o">*</span> <span class="n">PSLAC</span><span class="p">)</span>
                <span class="n">ZB</span> <span class="o">=</span> <span class="n">ZC2P1</span> <span class="o">*</span> <span class="n">PSLAC</span> <span class="o">+</span> <span class="n">ZC2M1</span>
                <span class="n">ZC</span> <span class="o">=</span> <span class="n">ZDBLC</span> <span class="o">*</span> <span class="n">PCLAP</span> <span class="o">*</span> <span class="n">ZCLAC</span> <span class="o">*</span> <span class="n">PCLOC</span> <span class="o">+</span> <span class="n">ZB</span> <span class="o">*</span> <span class="n">PSLAP</span>
                <span class="n">PSLAR</span> <span class="o">=</span> <span class="n">ZC</span> <span class="o">*</span> <span class="n">ZA</span>
                <span class="n">ZD</span> <span class="o">=</span> <span class="n">ZA</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ZEPS</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">PSLAR</span> <span class="o">*</span> <span class="n">PSLAR</span><span class="p">))</span>
                <span class="n">ZE</span> <span class="o">=</span> <span class="n">ZB</span> <span class="o">*</span> <span class="n">PCLAP</span> <span class="o">*</span> <span class="n">PCLOP</span> <span class="o">-</span> <span class="n">ZDBLC</span> <span class="o">*</span> <span class="n">ZCLAC</span> <span class="o">*</span> \
                     <span class="p">(</span><span class="n">PSLAP</span> <span class="o">*</span> <span class="n">PCLOC</span> <span class="o">*</span> <span class="n">PCLOP</span> <span class="o">-</span> <span class="n">PSLOP</span> <span class="o">*</span> <span class="n">PSLOC</span><span class="p">)</span>
                <span class="n">ZF</span> <span class="o">=</span> <span class="n">ZB</span> <span class="o">*</span> <span class="n">PCLAP</span> <span class="o">*</span> <span class="n">PSLOP</span> <span class="o">-</span> <span class="n">ZDBLC</span> <span class="o">*</span> <span class="n">ZCLAC</span> <span class="o">*</span> \
                     <span class="p">(</span><span class="n">PSLAP</span> <span class="o">*</span> <span class="n">PCLOC</span> <span class="o">*</span> <span class="n">PSLOP</span> <span class="o">+</span> <span class="n">PCLOP</span> <span class="o">*</span> <span class="n">PSLOC</span><span class="p">)</span>
                <span class="n">PCLOR</span> <span class="o">=</span> <span class="n">ZE</span> <span class="o">*</span> <span class="n">ZD</span>
                <span class="n">PSLOR</span> <span class="o">=</span> <span class="n">ZF</span> <span class="o">*</span> <span class="n">ZD</span>
                <span class="n">PSLAR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLAR</span><span class="p">))</span>
                <span class="n">PCLOR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PCLOR</span><span class="p">))</span>
                <span class="n">PSLOR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLOR</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Schmidt</span>
                <span class="n">PSLOR</span> <span class="o">=</span> <span class="n">PSLOC</span>
                <span class="n">PCLOR</span> <span class="o">=</span> <span class="n">PCLOC</span>
                <span class="n">PSLAR</span> <span class="o">=</span> <span class="p">(</span><span class="n">ZC2P1</span> <span class="o">*</span> <span class="n">PSLAC</span> <span class="o">+</span> <span class="n">ZC2M1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ZC2P1</span> <span class="o">+</span> <span class="n">ZC2M1</span> <span class="o">*</span> <span class="n">PSLAC</span><span class="p">)</span>
                <span class="n">PSLAR</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">PSLAR</span><span class="p">))</span>

            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">PSLOR</span><span class="p">,</span> <span class="n">PCLOR</span><span class="p">)</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">PSLAR</span><span class="p">)</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>

<div class="viewcode-block" id="D3GaussGeometry.map_factor"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.map_factor">[docs]</a>    <span class="k">def</span> <span class="nf">map_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the map factor at the given longitude/latitude(s)</span>

<span class="sd">        :param lon: longitude in degrees</span>
<span class="sd">        :param lat: latitude in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">]</span>
        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">plab</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_stretch</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="n">zlat1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">plab</span><span class="p">)</span>
        <span class="c1"># From rotated/streched sphere to rotated</span>
        <span class="n">zinterm</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">pc</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlat1</span><span class="p">))</span>
        <span class="n">zlat2</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">zinterm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">zinterm</span><span class="p">))</span>
        <span class="n">zm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat1</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">zm</span></div>

<div class="viewcode-block" id="D3GaussGeometry.map_factor_field"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.map_factor_field">[docs]</a>    <span class="k">def</span> <span class="nf">map_factor_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new field whose data is the map factor over the field.</span>

<span class="sd">        :param position: grid position with respect to the model cell.</span>
<span class="sd">          Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs_vcoord</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;structure&#39;</span><span class="p">:</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;typeoffirstfixedsurface&#39;</span><span class="p">:</span> <span class="mi">255</span><span class="p">,</span>
                         <span class="s1">&#39;position_on_grid&#39;</span><span class="p">:</span> <span class="s1">&#39;__unknown__&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;levels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
        <span class="n">vcoordinate</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs_vcoord</span><span class="p">)</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">geometrys</span><span class="o">.</span><span class="n">almost_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                              <span class="n">structure</span><span class="o">=</span><span class="s1">&#39;H2D&#39;</span><span class="p">,</span>
                                              <span class="n">vcoordinate</span><span class="o">=</span><span class="n">vcoordinate</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">fpx</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">structure</span><span class="o">=</span><span class="s1">&#39;H2D&#39;</span><span class="p">,</span>
                      <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span>
                      <span class="n">fid</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span><span class="s1">&#39;Map Factor&#39;</span><span class="p">},</span>
                      <span class="n">units</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lonlat_grid</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_factor</span><span class="p">(</span><span class="n">stretch_array</span><span class="p">(</span><span class="n">lons</span><span class="p">),</span> <span class="n">stretch_array</span><span class="p">(</span><span class="n">lats</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span></div>

<div class="viewcode-block" id="D3GaussGeometry.reproject_wind_on_lonlat"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.reproject_wind_on_lonlat">[docs]</a>    <span class="k">def</span> <span class="nf">reproject_wind_on_lonlat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span>
                                 <span class="n">map_factor_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reprojects a wind vector (u, v) on rotated/stretched sphere onto real</span>
<span class="sd">        sphere, i.e. with components on true zonal/meridian axes.</span>

<span class="sd">        :param u: the u == zonal-on-the-grid component of wind</span>
<span class="sd">        :param v: the v == meridian-on-the-grid component of wind</span>
<span class="sd">        :param lon: longitudes of points in degrees</span>
<span class="sd">        :param lat: latitudes of points in degrees</span>
<span class="sd">        :param map_factor_correction: applies a correction of magnitude due</span>
<span class="sd">                                      to map factor.</span>
<span class="sd">        :param reverse: if True, apply the reverse reprojection.</span>

<span class="sd">        lon/lat are coordinates on real sphere.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;rotated&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">plac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plac</span> <span class="o">=</span> <span class="mf">90.</span>
        <span class="p">(</span><span class="n">plob</span><span class="p">,</span> <span class="n">plab</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_stretch</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="c1"># the below formulas seem to be working with</span>
        <span class="c1"># lon_on_rotated_sphere begining below pole_of_rotation,</span>
        <span class="c1"># hence a 180° rotation.</span>
        <span class="n">plob</span> <span class="o">+=</span> <span class="mf">180.</span>
        <span class="n">pust</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">pvst</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># Adapted from J.M.Piriou&#39;s pastrv.F90</span>
        <span class="n">zlon1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">plob</span><span class="p">)</span>
        <span class="n">zlat1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">plab</span><span class="p">)</span>
        <span class="n">zlatp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">plac</span><span class="p">)</span>

        <span class="c1"># From rotated/streched sphere to rotated</span>
        <span class="n">zinterm</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">pc</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlat1</span><span class="p">))</span>
        <span class="n">zlat2</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">zinterm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">zinterm</span><span class="p">))</span>
        <span class="n">zlon2</span> <span class="o">=</span> <span class="n">zlon1</span>

        <span class="c1"># Map factor</span>
        <span class="k">if</span> <span class="n">map_factor_correction</span><span class="p">:</span>
            <span class="n">zm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat1</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span>
            <span class="c1"># zm = self.map_factor(lon, lat) # but redundant computations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">1.</span><span class="p">:</span>
                <span class="n">epylog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;check carefully *map_factor_correction* w.r.t. dilatation_coef&#39;</span><span class="p">)</span>
            <span class="n">zm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">zlat1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># From rotated sphere to real sphere</span>
        <span class="c1"># Compute latitude on real sphere</span>
        <span class="n">zsla3</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlon2</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlatp</span><span class="p">)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlatp</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">zsla3</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">zsla3</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">epylog</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;reproject_wind_on_lonlat: zsla3=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">zsla3</span><span class="p">))</span>
            <span class="n">zsla3</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">zsla3</span><span class="p">))</span>
        <span class="n">zlat3</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">zsla3</span><span class="p">)</span>

        <span class="c1"># Real North components</span>
        <span class="n">zca</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlatp</span><span class="p">)</span> <span class="o">+</span>
               <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlat2</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlatp</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlon2</span><span class="p">))</span> <span class="o">/</span> \
               <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat3</span><span class="p">)</span>
        <span class="n">zsa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlatp</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zlon2</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zlat3</span><span class="p">)</span>

        <span class="c1"># Wind transformation</span>
        <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">zm</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">zm</span>
            <span class="n">zsa</span> <span class="o">=</span> <span class="o">-</span><span class="n">zsa</span>
        <span class="n">pusr</span> <span class="o">=</span> <span class="n">zm</span> <span class="o">*</span> <span class="p">(</span><span class="n">zca</span> <span class="o">*</span> <span class="n">pust</span> <span class="o">-</span> <span class="n">zsa</span> <span class="o">*</span> <span class="n">pvst</span><span class="p">)</span>
        <span class="n">pvsr</span> <span class="o">=</span> <span class="n">zm</span> <span class="o">*</span> <span class="p">(</span><span class="n">zsa</span> <span class="o">*</span> <span class="n">pust</span> <span class="o">+</span> <span class="n">zca</span> <span class="o">*</span> <span class="n">pvst</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">pusr</span><span class="p">,</span> <span class="n">pvsr</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3GaussGeometry.nearest_points"><a class="viewcode-back" href="../../../library/D3Geometry.html#epygram.geometries.D3Geometry.D3GaussGeometry.nearest_points">[docs]</a>    <span class="k">def</span> <span class="nf">nearest_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span>
                       <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">external_distance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">squeeze</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the (i, j) position of the points needed to perform</span>
<span class="sd">        an interpolation.</span>

<span class="sd">        :param lon: longitude of point in degrees.</span>
<span class="sd">        :param lat: latitude of point in degrees.</span>
<span class="sd">        :param request: criteria for selecting the points, among:</span>
<span class="sd">               * {&#39;n&#39;:&#39;1&#39;} - the nearest point</span>
<span class="sd">               * {&#39;n&#39;:&#39;2*2&#39;} - the 2*2 square points around the position</span>
<span class="sd">               * {&#39;n&#39;:&#39;4*4&#39;} - the 4*4 square points around the position</span>
<span class="sd">               * {&#39;n&#39;:&#39;N*N&#39;} - the N*N square points around the position: N must be even</span>
<span class="sd">               * {&#39;radius&#39;:xxxx, &#39;shape&#39;:&#39;square&#39;} - the points which are xxxx metres</span>
<span class="sd">                 around the position in X or Y direction</span>
<span class="sd">               * {&#39;radius&#39;:xxxx, &#39;shape&#39;:&#39;circle&#39;} - the points within xxxx metres</span>
<span class="sd">                 around the position. (default shape == circle)</span>
<span class="sd">        :param position: position in the model cell of the lat lon position.</span>
<span class="sd">               Defaults to self.position_on_horizontal_grid.</span>
<span class="sd">        :param external_distance: can be a dict containing the target point value</span>
<span class="sd">               and an external field on the same grid as self, to which the distance</span>
<span class="sd">               is computed within the 4 horizontally nearest points; e.g.</span>
<span class="sd">               {&#39;target_value&#39;:4810, &#39;external_field&#39;:a_3DField_with_same_geometry}.</span>
<span class="sd">               If so, the nearest point is selected with</span>
<span class="sd">               distance = |target_value - external_field.data|</span>
<span class="sd">        :param squeeze: True to suppress useless dimensions</span>

<span class="sd">        :rtype: general output form is [list, list, ..., list]</span>
<span class="sd">                with as many list items as the length of lon/lat.</span>
<span class="sd">                Each list item is of the form [tuple, tuple, ..., tuple]</span>
<span class="sd">                with as many tuples as the request implies. A tuple</span>
<span class="sd">                represents one of the nearest points associated with one</span>
<span class="sd">                value taken from lon/lat. Each tuple as the form</span>
<span class="sd">                (i, j).</span>

<span class="sd">                Dimensions with a length of one are removed except if</span>
<span class="sd">                squeeze is False. If squeeze is True and if request</span>
<span class="sd">                implies only one nearest point, the list item of the general</span>
<span class="sd">                output form is replaced by the tuple item; if length of</span>
<span class="sd">                lon/lat is one, the output is directly the list item of</span>
<span class="sd">                the general output form. Hence, if length of lon/lat is</span>
<span class="sd">                one and the request implies only one point, the output is</span>
<span class="sd">                a tuple.</span>

<span class="sd">                In case of a simple square request, output is actually</span>
<span class="sd">                an array. Otherwise, the output is as described (it cannot</span>
<span class="sd">                be an array because the number of nearest points can vary</span>
<span class="sd">                with the entry point).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getoffset</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;horizontal staggered grids for &quot;</span> <span class="o">+</span>
                                      <span class="s2">&quot;reduced gauss grid are not implemented.&quot;</span><span class="p">)</span>

        <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># ## internal functions</span>
        <span class="k">def</span> <span class="nf">nearest_lats</span><span class="p">(</span><span class="n">latrs</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Internal method used to find the nearest latitude circles.</span>

<span class="sd">            *latrs* is the rotated and streched latitude.</span>
<span class="sd">            *num* is:</span>
<span class="sd">            - 2 to find the two surrounding latitude cicles,</span>
<span class="sd">            - 3 to find the nearest latitude circles plus the one above</span>
<span class="sd">                and the one under.</span>
<span class="sd">            - 4 to find the two surrounding latitude circles plus the</span>
<span class="sd">                preceding one and the following one.</span>
<span class="sd">            - and so on...</span>

<span class="sd">            returns an array of shape (len(latrs), num)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">latitudes</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">&lt;=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">latitudes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;latitudes must be in descending order&#39;</span><span class="p">)</span>

            <span class="n">latrs</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">latrs</span><span class="p">)</span>
            <span class="n">nearest</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">),</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">distmin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">),</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="c1"># Slicing is needed to prevent memory error</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># on a particular example, increasing this value implies a longuer execution time</span>
            <span class="k">for</span> <span class="n">imin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">):</span>
                <span class="n">imax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">imin</span> <span class="o">+</span> <span class="n">batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">))</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">latrs</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">latitudes</span><span class="p">)[</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">nearest</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dist</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">distmin</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">nearest</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imax</span><span class="p">]]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">),</span> <span class="n">num</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">distmin</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># odd</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">k</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># even</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">k</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">nearest</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">def</span> <span class="nf">nearest_lons</span><span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">latnum</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Internal method used to find the nearest points on a latitude</span>
<span class="sd">            circle.</span>

<span class="sd">            Args:\n</span>
<span class="sd">            - *lonrs* is the rotated and streched longitude.</span>
<span class="sd">            - *num* is:</span>
<span class="sd">              - 1 to find the nearest point,</span>
<span class="sd">              - 2 to find the two surrounding points,</span>
<span class="sd">              - 4 to find the two surrounding points plus the preceding one and</span>
<span class="sd">                  the following one.</span>
<span class="sd">              - and so on</span>
<span class="sd">            - *latnum*: if -1 (resp. -2), we search for the opposite longitude</span>
<span class="sd">              on the first (resp. second) latitude circle.</span>
<span class="sd">              The same is true for the other pole.</span>

<span class="sd">            latnum must be of shape (len(lonrs), x) where x is the number of latitude</span>
<span class="sd">            to search for each longitude</span>

<span class="sd">            result shape is (len(lonrs), x, num, 2)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">lonrs</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lonrs</span><span class="p">)</span>
            <span class="n">latnum</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">latnum</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lonrs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lonrs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">num</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">lonrs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">lonrs</span><span class="p">)</span>
            <span class="n">lonnummax</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">lonrs2d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">lonrs</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">latnum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Near the pole, have to look-up on the first latitudes</span>
            <span class="c1"># circles, symmetrically with regards to the pole</span>
            <span class="n">mask1</span> <span class="o">=</span> <span class="n">latnum</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">j</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">latnum</span><span class="p">[</span><span class="n">mask1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])[</span><span class="n">j</span><span class="p">[</span><span class="n">mask1</span><span class="p">]]</span>
            <span class="n">i</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">lonrs2d</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> \
                       <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">mask2</span> <span class="o">=</span> <span class="n">latnum</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">latitudes</span><span class="p">)</span>
            <span class="n">j</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">latitudes</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">latnum</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">latitudes</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># TOBECHECKED: next circle past the pole</span>
            <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])[</span><span class="n">j</span><span class="p">[</span><span class="n">mask2</span><span class="p">]]</span>
            <span class="n">i</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">lonrs2d</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> \
                            <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">mask2</span><span class="p">))</span>
            <span class="n">j</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">latnum</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lon_number_by_lat&#39;</span><span class="p">])[</span><span class="n">latnum</span><span class="p">[</span><span class="n">mask</span><span class="p">]]</span>
            <span class="n">i</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">lonrs2d</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">*</span> <span class="n">lonnummax</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">lonnummax</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">elif</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="n">lonnummax</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">lonnummax</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">elif</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># odd</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;but is it necessary ?&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># even</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ii</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="n">lonnummax</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">%</span> <span class="n">lonnummax</span>
                <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ii</span> <span class="o">+</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="n">lonnummax</span>  <span class="c1"># reverse order? why?</span>
                    <span class="n">result</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="k">def</span> <span class="nf">nearest</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Internal method used to find the nearest point.</span>
<span class="sd">            lon/lat are the true coordinate, lonrs/latrs are rotated and</span>
<span class="sd">            streched coordinates.</span>

<span class="sd">            Returns an array of points</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lonrs</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">latrs</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">lonrs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">latrs</span><span class="p">)</span>

            <span class="n">all_nearest_lats</span> <span class="o">=</span> <span class="n">nearest_lats</span><span class="p">(</span><span class="n">latrs</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">all_nearest_lons</span> <span class="o">=</span> <span class="n">nearest_lons</span><span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">all_nearest_lats</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">lon2d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">lon</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">lat2d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">lat</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">all_nearest_lons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                              <span class="n">all_nearest_lons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span>
            <span class="n">all_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">((</span><span class="n">lon2d</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">lat2d</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span> <span class="n">ll</span><span class="p">)</span>
            <span class="n">all_dist</span> <span class="o">=</span> <span class="n">all_dist</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lonrs</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">all_nearest_lons</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">all_dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">all_dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">def</span> <span class="nf">nearests</span><span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Internal methods used to find the n*n points surrunding the</span>
<span class="sd">            point lonrs/latrs, lonrs/latrs are rotated and stretched</span>
<span class="sd">            coordinates.</span>

<span class="sd">            lonrs and latrs can be arrays</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">lonrs</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">lonrs</span><span class="p">)</span>
            <span class="n">latrs</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">latrs</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">lonrs</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">latrs</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lonrs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;only scalar or 1d arrays with same length&quot;</span>

            <span class="n">all_nearest_lats</span> <span class="o">=</span> <span class="n">nearest_lats</span><span class="p">(</span><span class="n">latrs</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">all_nearest_lons</span> <span class="o">=</span> <span class="n">nearest_lons</span><span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">all_nearest_lats</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">all_nearest_lons</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">lonrs</span><span class="p">),</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># ## actual algorithm</span>
        <span class="c1"># initializations</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lon</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">lat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">latitudes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;latitudes&#39;</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">])]</span>
        <span class="c1"># compute rotated/stretched lon/lat</span>
        <span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_stretch</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
        <span class="c1"># 1.A: nearest point is needed only</span>
        <span class="n">nsquare_match</span> <span class="o">=</span> <span class="n">_re_nearest_sq</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nsquare_match</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">),</span> \
                <span class="s2">&quot;anisotropic request {&#39;n&#39;:&#39;N*M&#39;} is not supported.&quot;</span>
        <span class="k">if</span> <span class="n">external_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">request</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="s1">&#39;1&#39;</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">_increments</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;academic&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">i_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;academic&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">j_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j_incr</span> <span class="o">=</span> <span class="n">_rng</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">i_incr</span><span class="p">,</span> <span class="n">j_incr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">request</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;n&#39;</span><span class="p">:</span><span class="s1">&#39;1&#39;</span><span class="p">}</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">external_distance</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">nearest</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span><span class="p">)</span>
        <span class="c1"># 2.: several points are needed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 2.1: how many ?</span>
            <span class="k">if</span> <span class="n">external_distance</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;request:{&#39;radius&#39;:..., &#39;shape&#39;:&#39;radius&#39;} with several points.&quot;</span><span class="p">)</span>
                <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution_ll</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">resolution</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nsquare_match</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nsquare_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">epygramError</span><span class="p">(</span><span class="s2">&quot;unrecognized **request**: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">request</span><span class="p">))</span>
            <span class="c1"># 2.2: get points</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">nearests</span><span class="p">(</span><span class="n">lonrs</span><span class="p">,</span> <span class="n">latrs</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

            <span class="c1"># 2.3: only select the nearest with regards to external_distance</span>
            <span class="k">if</span> <span class="n">external_distance</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># We transform into list to be able to modify the length</span>
                <span class="k">for</span> <span class="n">ipt</span><span class="p">,</span> <span class="n">points</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                    <span class="n">mindistance</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">external_distance</span><span class="p">[</span><span class="s1">&#39;external_field&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getvalue_ij</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">one</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-</span> <span class="n">external_distance</span><span class="p">[</span><span class="s1">&#39;target_value&#39;</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">mindistance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">mindistance</span><span class="p">:</span>
                            <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
                            <span class="n">mindistance</span> <span class="o">=</span> <span class="n">dist</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># all item must now have the same length</span>

        <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;radius&#39;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># We transform into list to be able to modify the length</span>
            <span class="k">for</span> <span class="n">ipt</span><span class="p">,</span> <span class="n">points</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;circle&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;circle&#39;</span><span class="p">:</span>
                    <span class="c1">#for i,j in points:</span>
                    <span class="c1">#    print(i,j,self.distance((lon[ipt], lat[ipt]), self.ij2ll(i, j)))</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">points</span>
                                   <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance</span><span class="p">((</span><span class="n">lon</span><span class="p">[</span><span class="n">ipt</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">ipt</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ij2ll</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">request</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;square&#39;</span><span class="p">:</span>
                    <span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">points</span>
                                   <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ll2xy</span><span class="p">(</span><span class="n">lon</span><span class="p">[</span><span class="n">ipt</span><span class="p">],</span> <span class="n">lat</span><span class="p">[</span><span class="n">ipt</span><span class="p">]))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ij2xy</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)))</span> <span class="o">&lt;=</span> <span class="n">request</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">])]</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">ipt</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;no points found: radius may be too small.&quot;</span>
            <span class="k">if</span> <span class="n">squeeze</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">squeeze</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span> <span class="nf">_what_grid_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">spectral_geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes in file a summary of the grid &amp; dimensions of the field.</span>

<span class="sd">        :param out: the output open file-like object</span>
<span class="sd">        :param spectral_geometry: an optional dict containing the spectral</span>
<span class="sd">          truncature {&#39;max&#39;:}.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span>
        <span class="n">gridmap</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;reduced_gauss&#39;</span><span class="p">:</span><span class="s1">&#39;Reduced Gauss&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">:</span><span class="s1">&#39;Rotated Reduced Gauss&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;regular_gauss&#39;</span><span class="p">:</span><span class="s1">&#39;Regular Gauss&#39;</span><span class="p">}</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Grid&quot;</span><span class="p">,</span> <span class="n">gridmap</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;rotated_reduced_gauss&#39;</span><span class="p">:</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Pole Longitude&quot;</span><span class="p">,</span>
                            <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Pole Latitude&quot;</span><span class="p">,</span>
                            <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;pole_lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">))</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Dilatation coefficient&quot;</span><span class="p">,</span>
                        <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;dilatation_coef&#39;</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Number of latitudes&quot;</span><span class="p">,</span>
                        <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;lat_number&#39;</span><span class="p">])</span>
        <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Maximum number of longitudes on a parallel&quot;</span><span class="p">,</span>
                        <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;max_lon_number&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">spectral_geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">write_formatted</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s2">&quot;Truncation&quot;</span><span class="p">,</span>
                            <span class="n">spectral_geometry</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">])</span></div>

<span class="n">footprints</span><span class="o">.</span><span class="n">collectors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="s1">&#39;geometrys&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fasttrack</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;structure&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">epygram 1.4.18 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../epygram.html" >epygram</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../geometries.html" >epygram.geometries</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">epygram.geometries.D3Geometry</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014 --- 2022, A.Mary, S.Riette.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.2.
    </div>
  </body>
</html>